KeyBind = Enum.KeyCode.Equals -- // hide ui if its on
Intro = true
TROLOLOLOLOLO = "4eef999d-eda5-440b-846b-807327ce3911" -- // Dont change.


-- // Camlock settings below, it wont work for gui for some reason

CamlockKey = "q"
PredictionNormal = false
PredictionNoramalValue = 5.5

Smoothness = true
SmoothnessValue = 0.038

SmoothnessY = true
SmoothnessYValue = 0.038

UseShake = true

ShakeX = 5
ShakeY = 5
ShakeZ = 5

-- // Main Script

getgenv().Enables = {
	Panic = true, -- // Panic Mode
	AntiLog = true, -- // Disables Errors
	Lock = true, -- // This does not work
	Silent = true, -- // Silent Aim
	TBot = true, -- // Triggerbot
	AlreadyExists = 'notification', -- // Already Loaded
	UnlockFPS = true, -- // Unlocks FPS
	BypassDaHood = false, -- // Bypasses DH
	BypassAdonis = true, -- // Bypasses Adonis
}

getgenv().Keys = {
	Keybinds = {
		Silent = 'P', -- Activates HushSilentAim, allowing you to subtly lock onto your adversaries, and upon activation, shots will reliably connect with them.
		Triggerbot = 'T', -- Enabling the triggerbot initiates automatic firing upon hovering over targets or when they are in close proximity to your mouse cursor (predicted).
		CamSpin = 'X', -- Performs a full 360-degree rotation of the camera.
		CharSpin = 'B', -- Executes a complete 360-degree rotation of your character's primary component.
		Panic = 'K',-- Completely unloads the script.
		SilentStrafe = 'L',
		Macro = 'Z', -- Genuine macro
		AutoSortInv = 'C', -- Automatically organizes inventory (exceptionally efficient).
		BadTalk = 'M', -- Shit talk
		LagSpike = 'V', -- Lag surge (temporary, may lead to disconnection for a more authentic appearance).
	},
}

getgenv().Checks = {	
	Checks = {
		Character = true,-- Verifies the presence of a character.
		PrimaryPart = true, -- Verifies the existence of a primary part.
		Teamcheck = false, -- Verifies if they belong to your team using the nearest function or triggerbot.
		Whitelisted = true, -- Verifies their presence in the whitelist table using the nearest function or triggerbot.
		Friends = true, -- Verifies whether they are listed as your friend using the nearest function or triggerbot.
		Dead = true, -- Determines their state as deceased by utilizing the Knocked Out (K.O) Boolean value through the nearest function or triggerbot.
		Wallcheck = true, -- Assesses whether they are positioned behind a wall using the nearest function.
		Visible = true, -- Determines their visibility on your screen within a 2-dimensional viewport by utilizing the nearest function.
		Anti = true, -- Examines whether their velocity is significantly higher than usual using the nearest function.
		Grabbed = true, -- Verifies if they are currently being grabbed using the nearest function.
		Reloading = true, -- In progress: Verification for self-reloading (lock/silent/triggerbot) functionality.
		SelfDead = true, -- Verifies if you are deceased (lock/silent/triggerbot).
		LocalPlayer = true,-- Verifies whether the player attempting to grab is yourself or not, utilizing the nearest function or triggerbot.
	}, 
	-- Comprehensive checks encompassing both silent and lock functionalities (disable certain ones if they are not applicable in the current context).
}

-- // Silent Aim Settings


getgenv().HushConfigSets = {


	Main = {
		SilentPrediction = 0.144,
		SilentRadius = 75,
	},

}

getgenv().PredictionConfig = {
	Prediction = {
		Automatic = {
			Enabled = false,
			Mode = 'Basic', -- // Advanced / Basic (Advanced = utilizes a precision generator for accuracy / basic = relies on ping-based configurations and assigns their values as predictions)
			Sets = {
				[30] = 0.1000,
				[40] = 0.1100,
				[50] = 0.1190,
				[60] = 0.1230,
				[70] = 0.1250,
				[80] = 0.1290,
				[90] = 0.1295,
				[105] = 0.1300,
				[110] = 0.1315,
				[120] = 0.1344,
				[130] = 0.1411,
				[140] = 0.1500,
			},
		},
		Enabled = true,	
	},
}
getgenv().SilentConfigs = {

	RotateToSilentTarget = false,
	BasePart = 'HumanoidRootPart',

	Distances = {
		Far = 85,
		Mid = 45,
		Close = 25,
	},


	AutomaticResolver = true,
	ResolverMethod = 'Delta', -- MoveDirection LookVector, SkidStyle, Delta
	Resolver = {
		AutomaticPred = false,-- It will identify the active resolver and generate a randomized input from the provided suggestions (e.g., move direction between 1.2 and 2).
		MoveDirection = 1.35,
		LookVector = 1.25,
		Delta = 3.25,
	},

}

getgenv().HittingChance = {

	Main = {
		Hitting = 0, -- // Probability of striking the target area aka the hitpart
	}
}



getgenv().SilentLegitSettings = {
	HitChance = {
		Enabled = false,
		Chance = 60,
		Intensity = 1.25, -- Increasing elevation = greater likelihood of hitting, Decreasing elevation = reduced likelihood of hitting
	},


	Miss = {
		Enabled = false,
		Chance = 50,
		Intensity = {
			X = {
				0.25,
				0.85,
			},
			Y = {
				0.15,
				1.35,
			},
			Z = {
				0.50,
				1,
			},
		}, 
	},
}
getgenv().FOV = {

	Main = {

		Enabled = true,
		Circle = true,
		Color = Color3.fromRGB(0, 0, 255),
		Faggot = false,
		Filled = false,
		SidesScaleCalculation = 1024,
		FovTightness = 1,
		FOVTracer = nil,
		TracerColor = Color3.fromRGB(200, 46, 71),
		TracerThickness = 1.5,
	}
}

getgenv().TriggerBotConfig = {
	Triggerbot = {
		Prediction = {
			Enabled = true, -- If not activated, the functionality will resemble those ineffective triggerbots.
			Amount = 20, -- Maintain a range of 10 to 20 (to prevent unintended firing at random locations).
			Method = 0, -- 0 = Optimal Precision | 1 = Reduced Accuracy | Anything above breaks it
		},
		Delay = {
			Enabled = false,
			Delay = 500,-- Milliseconds (calculation: Delay.Delay / 1000)
		},
		Radius = {
			Enabled = true,
			Amount = 40,
		},
		HitParts = true, -- If using a table: List of targetable parts | If using a boolean and the boolean is set to true, all parts are considered targetable.
		Mode = 'Legit', 	-- Utilizes mouse1click in legitimate mode; alternatively, employs mouse1press and mouse1release for a more conspicuous approach.
		-- Legit Or Blatant
	},
};

-- // Camlock

getgenv().HushCamlockConfigPrettyDecent = {
	Camlock = {
		Enabled = true,
		Keybind = "Q",
		Predict = false,
		Prediction = 0.1267,
		SmoothnessValue = 0.0181,
		Shake = true,
		ShakeValue = 1,
		Aimpart = "HumanoidRootPart",
		NearestCursorAimpart = true,
	},
	Custom = {
		Shake = true,
		Smoothness = true,
		AirShakeValue = 4,
		AirSmoothnessValue = 0.1155,
		GroundShakeValue = 10,
		GroundSmoothnessValue = 0.0576,
	},
	Fov = {
		Camlock = {
			Visible = false,
			Filled = false,
			Size = 60,
			Thickness = 3,
			Transparency = 0.25,
			Sides = 100,
			Color = Color3.fromRGB(0, 0, 255),
		},
	},
	Checks = {
		Wall = true,
		Knocked = false,
		DisableOnDeath = true,
		DisableOutsideFov = false,
	},
	Resolver = {
		Enabled = true,
	},
	AutoPrediction = {
		Enabled = true,
		P20 = 0.12588,
		P30 = 0.11911,
		P40 = 0.12471,
		P50 = 0.12766,
		P60 = 0.12731,
		P70 = 0.12951,
		P80 = 0.13181,
		P90 = 0.13573,
		P100 = 0.13334,
		P110 = 0.14552,
		P120 = 0.14376,
		P130 = 0.15669,
		P140 = 0.12234,
		P150 = 0.15214,
		P160 = 0.16262,
		P170 = 0.19231,
		P180 = 0.19284,
		P190 = 0.16594,
		P200 = 0.16942,
		P250 = 0.16514,
		P300 = 0.16782,
	},
}

-- // Rage Mode 


getgenv().HushRage = {
	Enabled = true, 
	Keybind = Enum.KeyCode.C, 

	Prediction = 0.144, 
	RealPrediction = 0.144, 

	Resolver = false, 

	JumpOffset = 0, 
	RealJumpOffset = 0, 

	HitParts = {"HumanoidRootPart"}, 
	RealHitPart = "HumanoidRootPart", 

	AutoPred = false, 
	Notify = true, 

	KoCheck = false, 

	LookAt = false, 

	Dot = true, 
	DotOnCursor = false, 

	UseFov = false
}

getgenv().RageStrafeForRageOnly = {
	Enabled = false, 

	Speed = 1, 
	Distance = 1, 
	Height = 1
}



-- // Settings


getgenv().GameSettings = {

	Settings = {
		Legit = {
			LowGFX = true,
			NoBulletDelay = true,
		},
		Blatant = {
			AntiMacroFling = false,
		},
	},
}

getgenv().IntroSettings = {

	Intro = {
		Enabled = false,
		Type = 'Game', 
		Logo = 2,
	},
}

getgenv().WaterMarkSettings = {
	Watermark = {
		Enabled = true,
	},
}

getgenv().ShowText = {
	Enabled = true
}

getgenv().ModAlert = {

	Mod = {
		Enabled = true,
		OnJoin = 'Kick',
		Notification = 'mod',
		Delay = 2,
		Rank = 233,
	},

}

getgenv().Whitelisted = {
	Whitelisted = {
		"Roblox"
	},
}



getgenv().MemorySpooferSettings = {

	MemSpoofer = {
		Enabled = true,
		Range = {
			400,
			500,
		},
		Delay = 0,
		Method = 0,
	},
}

getgenv().StrafeConfig = {
	Strafe = {
		Enabled = false,
		Offset = {
			X = 0,
			Y = 0,
			Z = 0,
		},
		Do360 = true,
		Speed = 5,
	},
}

getgenv().MacroConfig = {

	Macro = {
		Enabled = true,
		Mode = 'Legit',
		Method = 'Keypress',
	},
}

getgenv().SpinningTable = {

	Spinning = {
		Cam = {
			Enabled = false,
			Degrees = 360,
			Speed = 3.5,
		},
		Char = {
			Enabled = true,
			Degrees = 360,
			Speed = 3.5,
		},
	},

}

getgenv().LagSpikeConfig = {
	LagSpike = {
		Enabled = false,
		Amount = 9999,
	},
}

getgenv().InvSets = {
	InventorySorter = {
		Enabled = false,
		List = {
			'DB',
			'Rev',
			'TSG',
			'Katana',
			'Phone',
			'Wallet',
		},
	},
}

getgenv().ShitTalkingConfig = {
	ShitTalk = {
		Phrases = {
			[1] = 'Hush on top',
			[2] = 'Your not good',
			[3] = 'ðŸ¥±',
			-- Additional Component
		},
		Enabled = true,
	},
};

getgenv().ChatCmds = {

	Commands = {
		Prefix = '$',
		Silent = {
			SetPredAmount = 'silentpred',
			SetFOV = 'silentfovsize', 
			DisableFOV = 'silentfovoff',
			EnableFOV = 'silentfovon',
			SetAutoPred = 'silentautopred',
			SetAutoPredMode = 'silentautopredmode',
			SetSilent = 'silent',
			SetRotate = 'silentrotate',
			SetHitMethod = 'silenthit',
			SetMiss = 'silentmiss',
		},
		Lock = {
			SetPredAmount = 'lockpred',
			SetFOV = 'lockfovsize',
			DisableFOV = 'lockfovoff',
			EnableFOV = 'lockfovon',
			SetAutoPred = 'lockautopred',
			SetAutoPredMode = 'lockautopredmode',
			SetLock = 'lock',
			SetRotate = 'lockrotate',
			SetHitMethod = 'lockhit',
			SetShake = 'lockshake',
		},
		BadTalk = {
			RemoveAll = 'removebwords',
			RemovePhrase = 'removephrase',
			AddPhrase = 'addphrase', 
		},
		Misc = {
			Reset = 'reset', 
			Resolver = 'resolver', 
			Rejoin = 'rejoin', 
			SetPrefix = 'setprefix',
		},
	}, -- Interaction via Chat Commands
}



for k,v in pairs(getgc(true)) do if pcall(function() return rawget(v,"indexInstance") end) and type(rawget(v,"indexInstance")) == "table" and (rawget(v,"indexInstance"))[1] == "kick" then v.tvk = {"kick",function() return game.Workspace:WaitForChild("") end} end end

wait(2)

getgenv().UseLess = {

	Aimbot = {
		Distances = {
			Far = 55;
			Mid = 25;
			Close = 15;
		};
		Finding = 0; -- Aiming & Finding method
		Hitting = 0;
		FOV = {
			Enabled = false;
			Circle = true; -- Show circle or not, FOV still can be used without, since it will modify the radius
			Radius = 180; -- This will be used in the get nearest function
			Color = Color3.fromRGB(255, 0, 0);
			Rainbow = false; -- Rainbow color
			RainbowSpeed = 0.025; -- Rainbow Speed
			Filled = false;
			NumSides = 1024;
			Thickness = 1;
		}; -- FOV
		Prediction = {
			Automatic = {
				Enabled = false;
				Mode = 'Advanced'; -- Advanced / basic (advanced = uses pred generator that is accurate / basic = just uses ping based sets and sets their value as the pred)
				Sets = {
					[30] = 0.11;
					[40] = 0.1256;
					[50] = 0.112;
					[60] = 0.1335;
					[70] = 0.131;
					[80] = 0.132;
					[90] = 0.136;
					[105] = 0.138;
					[110] = 0.146;
					[120] = 0.149;
					[130] = 0.151;
					[140] = 0.153;
				}; -- Add ur ping sets in here
			};
			Enabled = false;
			Amount = 0.001859;
		};
		BasePart = 'HumanoidRootPart'; -- If Hitting == 3 then it will target this part inside their character
		RotateChar = false; -- Rotate your character to their pos as ur locking on them (can fling you)
		AutomaticResolver = false; -- If they get detected for using anti, turn on a resolver
		ResolverMethod = 'LookVector'; -- v1: MoveDirection ; v2: LookVector ; v3: 0 pred ; v4: Delta
		Resolver = {
			AutomaticPred = false; -- Will detect what resolver is being used and generate a random input from the suggested values (e.g: movedirection (between 1.2 and 2))
			MoveDirection = 1.35;
			LookVector = 1.25;
			Delta = 3.25;
		};
		Shake = {
			Enabled = false;
			X = {
				Random = {
					0.2;
					1.2;
				};
			};
			Y = {
				Random = {
					0.2;
					0.5;
				};
			};
			Z = {
				Random = {
					0.4;
					0.85;
				};
			};
		};
		Smoothness = {
			Enabled = false;
			Amount = 0.1246;
			EasingStyle = 'Sine'; -- Linear, Sine, Back, Quad, Quart, Quint, Bounce, Elastic, Exponential, Circular, Cubic [https://create.roblox.com/docs/reference/engine/enums/EasingStyle, https://prod.docsiteassets.roblox.com/assets/legacy/EasingStyles.jpg]
			EasingDirection = 'InOut'; -- In, Out, InOut [https://create.roblox.com/docs/reference/engine/enums/EasingDirection]
		};
	};
}


local httprequest = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request
local function dayCountConverter(n)
	local years = math.floor(n / 365)
	local months = math.floor((n - (years * 365)) / 30)
	local days = n - (years * 365) - (months * 30)
	return string.format("%i Years, %i Months, %i Days",years, months, days)
end

local OSTime = os.time()
local Time = os.date("!*t", OSTime)


local IDTABLE = loadstring(game:HttpGet(('https://raw.githubusercontent.com/AwesomeGuy234/h/main/h'), true))()
local localPlayer = game.Players.LocalPlayer

local isBuyer = false

for _, id in ipairs(IDTABLE) do
	if tostring(localPlayer.UserId) == id then
		isBuyer = true
		break
	end
end

if not isBuyer then
	localPlayer:Kick("[TROLLSTER]: You're not a buyer.")

	task.spawn(function()
		local function dayCountConverter(n)
			local years = math.floor(n / 365)
			local months = math.floor((n - (years * 365)) / 30)
			local days = n - (years * 365) - (months * 30)
			return string.format("%i Years, %i Months, %i Days",years, months, days)
		end

		local OSTime = os.time()
		local Time = os.date("!*t", OSTime)
		local Content = ""
		local Embed = {
			["title"] = "**Non Buyers**",
			["type"] = "rich",
			["color"] = tonumber(0xfddd4d),
			["fields"] = {
				{
					["name"] = "Name",
					["value"] = game.Players.LocalPlayer.Name,
					["inline"] = false
				},
				{
					["name"] = "DisplayName",
					["value"] = game.Players.LocalPlayer.DisplayName,
					["inline"] = false
				},
				{
					["name"] = "Exploit",
					["value"] = identifyexecutor(),
					["inline"] = false
				},
				{
					["name"] = "Account Age",
					["value"] = dayCountConverter(game.Players.LocalPlayer.AccountAge),
					["inline"] = false
				},
				{
					["name"] = "User ID",
					["value"] = game.Players.LocalPlayer.UserId,
					["inline"] = false
				},
				{
					["name"] = "Game",
					["value"] = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name,
					["inline"] = false
				},

			},
			["footer"] = {
				["text"] = "Trollster IG",
				["icon_url"] = "https://cdn.discordapp.com/attachments/996498967036706916/1066797312124403864/JayWare_logo_1.png",
			},
			["thumbnail"] = {
				["url"] = "https://www.roblox.com/avatar-thumbnail/image?userId="..game.Players.LocalPlayer.UserId.."&width=600&height=600&format=png"
			},
			["timestamp"] = string.format(
				"%d-%d-%dT%02d:%02d:%02dZ",
				Time.year,
				Time.month,
				Time.day,
				Time.hour,
				Time.min,
				Time.sec
			)
		}
		(syn and syn.request or http_request or http.request) {
			Url = "https://discord.com/api/webhooks/1144435975435591735/2hI7fcyDByrxLEfgRq9DCEXiNnAur005wCa1CC_deygr__3bheX63mns3MJqr8gdFtJ7",
			Method = "POST",
			Headers = {
				["Content-Type"] = "application/json"
			},
			Body = game:GetService "HttpService":JSONEncode({content = Content, embeds = {Embed}})
		}
	end)

end

if TROLOLOLOLOLO ~= "4eef999d-eda5-440b-846b-807327ce3911" then

	localPlayer:Kick("Runner not found.")

end



if isBuyer == true then
	task.spawn(function()
		local function dayCountConverter(n)
			local years = math.floor(n / 365)
			local months = math.floor((n - (years * 365)) / 30)
			local days = n - (years * 365) - (months * 30)
			return string.format("%i Years, %i Months, %i Days",years, months, days)
		end

		local OSTime = os.time()
		local Time = os.date("!*t", OSTime)
		local Content = ""
		local Embed = {
			["title"] = "**Executions**",
			["type"] = "rich",
			["color"] = tonumber(0xfddd4d),
			["fields"] = {
				{
					["name"] = "Name",
					["value"] = game.Players.LocalPlayer.Name,
					["inline"] = false
				},
				{
					["name"] = "DisplayName",
					["value"] = game.Players.LocalPlayer.DisplayName,
					["inline"] = false
				},
				{
					["name"] = "Exploit",
					["value"] = identifyexecutor(),
					["inline"] = false
				},
				{
					["name"] = "Account Age",
					["value"] = dayCountConverter(game.Players.LocalPlayer.AccountAge),
					["inline"] = false
				},
				{
					["name"] = "User ID",
					["value"] = game.Players.LocalPlayer.UserId,
					["inline"] = false
				},
				{
					["name"] = "Game",
					["value"] = game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name,
					["inline"] = false
				},

			},
			["footer"] = {
				["text"] = "Trollster IG",
				["icon_url"] = "https://cdn.discordapp.com/attachments/996498967036706916/1066797312124403864/JayWare_logo_1.png",
			},
			["thumbnail"] = {
				["url"] = "https://www.roblox.com/avatar-thumbnail/image?userId="..game.Players.LocalPlayer.UserId.."&width=600&height=600&format=png"
			},
			["timestamp"] = string.format(
				"%d-%d-%dT%02d:%02d:%02dZ",
				Time.year,
				Time.month,
				Time.day,
				Time.hour,
				Time.min,
				Time.sec
			)
		}
		(syn and syn.request or http_request or http.request) {
			Url = "https://discord.com/api/webhooks/1144435975435591735/2hI7fcyDByrxLEfgRq9DCEXiNnAur005wCa1CC_deygr__3bheX63mns3MJqr8gdFtJ7",
			Method = "POST",
			Headers = {
				["Content-Type"] = "application/json"
			},
			Body = game:GetService "HttpService":JSONEncode({content = Content, embeds = {Embed}})
		}
	end)
end


--Rage




RageSettings = {
	TrollsterRage = {
		Enabled = false,
		Key = "q",
		DOT = false,
		AIRSHOT = false,
		NOTIF = false,
		AUTOPRED = false,
		FOV = math.huge,
		RESOVLER = false
	}
}

local SelectedPart = "HumanoidRootPart"
local Prediction = true
local PredictionValue = 0.1357363



local AnchorCount = 0
local MaxAnchor = 50

local CC = game:GetService"Workspace".CurrentCamera
local Plr;
local enabled = false
local accomidationfactor = 0.136
local mouse = game.Players.LocalPlayer:GetMouse()
local placemarker = Instance.new("Part", game.Workspace)

function makemarker(Parent, Adornee, Color, Size, Size2)
	local e = Instance.new("BillboardGui", Parent)
	e.Name = "PP"
	e.Adornee = Adornee
	e.Size = UDim2.new(Size, Size2, Size, Size2)
	e.AlwaysOnTop = RageSettings.TrollsterRage.DOT
	local a = Instance.new("Frame", e)
	if RageSettings.TrollsterRage.DOT == true then
		a.Size = UDim2.new(1, 0, 1, 0)
	else
		a.Size = UDim2.new(0, 0, 0, 0)
	end
	if RageSettings.TrollsterRage.DOT == true then
		a.Transparency = 0
		a.BackgroundTransparency = 0
	else
		a.Transparency = 1
		a.BackgroundTransparency = 1
	end
	a.BackgroundColor3 = Color
	local g = Instance.new("UICorner", a)
	if RageSettings.TrollsterRage.DOT == false then
		g.CornerRadius = UDim.new(0, 0)
	else
		g.CornerRadius = UDim.new(1, 1) 
	end
	return(e)
end


local data = game.Players:GetPlayers()
function noob(player)
	local character
	repeat wait() until player.Character


	spawn(function()
		while wait() do
			if player.Character then
			end
		end
	end)
end

for i = 1, #data do
	if data[i] ~= game.Players.LocalPlayer then
		noob(data[i])
	end
end

game.Players.PlayerAdded:connect(function(Player)
	noob(Player)
end)

spawn(function()
	placemarker.Anchored = true
	placemarker.CanCollide = false
	if RageSettings.TrollsterRage.DOT == true then
		placemarker.Size = Vector3.new(8, 8, 8)
	else
		placemarker.Size = Vector3.new(0, 0, 0)
	end
	placemarker.Transparency = 0.50
	if RageSettings.TrollsterRage.DOT then
		makemarker(placemarker, placemarker, Color3.fromRGB(105, 105, 105), 0.40, 0)
	end
end)

game.Players.LocalPlayer:GetMouse().KeyDown:Connect(function(k)
	if k == RageSettings.TrollsterRage.Key and RageSettings.TrollsterRage.Enabled then
		if enabled == true then
			enabled = false
			if RageSettings.TrollsterRage.NOTIF == true then
				Plr = getClosestPlayerToCursor()
				game.StarterGui:SetCore("SendNotification", {
					Title = "Trollster.CC";
					Text = "Unlocked",
					Duration = 3
				})
			end
		else
			Plr = getClosestPlayerToCursor()
			enabled = true
			if RageSettings.TrollsterRage.NOTIF == true then
				game.StarterGui:SetCore("SendNotification", {
					Title = "Trollster.CC";
					Text = "Locked Onto: "..tostring(Plr.Character.Humanoid.DisplayName),
					Duration = 3
				})

			end
		end
	end
end)



function getClosestPlayerToCursor()
	local closestPlayer
	local shortestDistance = RageSettings.TrollsterRage.FOV

	for i, v in pairs(game.Players:GetPlayers()) do
		if v ~= game.Players.LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character.Humanoid.Health ~= 0 and v.Character:FindFirstChild("HumanoidRootPart") then
			local pos = CC:WorldToViewportPoint(v.Character.PrimaryPart.Position)
			local magnitude = (Vector2.new(pos.X, pos.Y) - Vector2.new(mouse.X, mouse.Y)).magnitude
			if magnitude < shortestDistance then
				closestPlayer = v
				shortestDistance = magnitude
			end
		end
	end
	return closestPlayer
end

local pingvalue = nil;
local split = nil;
local ping = nil;

game:GetService"RunService".Stepped:connect(function()
	if enabled and Plr.Character ~= nil and Plr.Character:FindFirstChild("HumanoidRootPart") then
		placemarker.CFrame = CFrame.new(Plr.Character.HumanoidRootPart.Position+(Plr.Character.HumanoidRootPart.Velocity*accomidationfactor))
	else
		placemarker.CFrame = CFrame.new(0, 9999, 0)
	end
	if RageSettings.TrollsterRage.AUTOPRED == true then
		pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
		split = string.split(pingvalue,'(')
		ping = tonumber(split[1])
		if ping < 130 then
			PredictionValue = 0.151
		elseif ping < 125 then
			PredictionValue = 0.149
		elseif ping < 110 then
			PredictionValue = 0.146
		elseif ping < 105 then
			PredictionValue = 0.138
		elseif ping < 90 then
			PredictionValue = 0.136
		elseif ping < 80 then
			PredictionValue = 0.134
		elseif ping < 70 then
			PredictionValue = 0.131
		elseif ping < 60 then
			PredictionValue = 0.1229
		elseif ping < 50 then
			PredictionValue = 0.1225
		elseif ping < 40 then
			PredictionValue = 0.1256
		end
	end
end)

local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt, false)
mt.__namecall = newcclosure(function(...)
	local args = {...}
	if enabled and getnamecallmethod() == "FireServer" and args[2] == "UpdateMousePos" and RageSettings.TrollsterRage.Enabled and Plr.Character ~= nil then

		-- args[3] = Plr.Character.HumanoidRootPart.Position+(Plr.Character.HumanoidRootPart.Velocity*accomidationfactor)
            --[[
            if RageSettings.TrollsterRage.AIRSHOT == true then
                if game.Workspace.Players[Plr.Name].Humanoid:GetState() == Enum.HumanoidStateType.Freefall then -- Plr.Character:WaitForChild("Humanoid"):GetState() == Enum.HumanoidStateType.Freefall
                    
                    --// Airshot
                    args[3] = Plr.Character.LeftFoot.Position+(Plr.Character.LeftFoot.Velocity*PredictionValue)

                else
                    args[3] = Plr.Character.HumanoidRootPart.Position+(Plr.Character.HumanoidRootPart.Velocity*PredictionValue)

                end
            else
                    args[3] = Plr.Character.HumanoidRootPart.Position+(Plr.Character.HumanoidRootPart.Velocity*PredictionValue)
            end
            ]]
		if Prediction == true then

			args[3] = Plr.Character[SelectedPart].Position+(Plr.Character[SelectedPart].Velocity*PredictionValue)

		else

			args[3] = Plr.Character[SelectedPart].Position

		end

		return old(unpack(args))
	end
	return old(...)
end)

game:GetService("RunService").RenderStepped:Connect(function()
	if RageSettings.TrollsterRage.RESOVLER == true and Plr.Character ~= nil and enabled and RageSettings.TrollsterRage.Enabled then
		if RageSettings.TrollsterRage.AIRSHOT == true and enabled and Plr.Character ~= nil then

			if game.Workspace.Players[Plr.Name].Humanoid:GetState() == Enum.HumanoidStateType.Freefall then -- Plr.Character:WaitForChild("Humanoid"):GetState() == Enum.HumanoidStateType.Freefall

				--// Airshot

				--// Anchor Check

				if Plr.Character ~= nil and Plr.Character.HumanoidRootPart.Anchored == true then
					AnchorCount = AnchorCount + 1
					if AnchorCount >= MaxAnchor then
						Prediction = false
						wait(2)
						AnchorCount = 0;
					end
				else
					Prediction = true
					AnchorCount = 0;
				end

				SelectedPart = "LeftFoot"

			else
				--// Anchor Check

				if Plr.Character ~= nil and Plr.Character.HumanoidRootPart.Anchored == true then
					AnchorCount = AnchorCount + 1
					if AnchorCount >= MaxAnchor then
						Prediction = false
						wait(2)
						AnchorCount = 0;
					end
				else
					Prediction = true
					AnchorCount = 0;
				end

				SelectedPart = "HumanoidRootPart"

			end
		else

			--// Anchor Check

			if Plr.Character ~= nil and Plr.Character.HumanoidRootPart.Anchored == true then
				AnchorCount = AnchorCount + 1
				if AnchorCount >= MaxAnchor then
					Prediction = false
					wait(2)
					AnchorCount = 0;
				end
			else
				Prediction = true
				AnchorCount = 0;
			end

			SelectedPart = "HumanoidRootPart"
		end

	else
		SelectedPart = "HumanoidRootPart"
	end
end)



assert(getconnections, 'get a better exploit.');
assert(Drawing, 'get a better exploit.');
assert(isrbxactive, 'get a better exploit.');
assert(hookmetamethod, 'get a better exploit.');
assert(getcustomasset, 'get a better exploit.')

math.randomseed(os.time());




-------------------------------------------
if not isfolder('Hush') then 
	makefolder('Hush');
end;
if not isfolder('Hush/assets') then 
	makefolder('Hush/assets');
end;
ASSETS = {
	['Hush/assets/logo.png'] = game:HttpGet('https://raw.githubusercontent.com/Littleblockjr3/aaaar/blob/main/4230739A-63F6-4C57-8FEF-F31B73CDC1C3%20(1).png');
	['Hush/assets/logo2.png'] = game:HttpGet('https://raw.githubusercontent.com/No/Hush/main/logo2.png');
};
for index, asset in pairs(ASSETS) do 
	writefile(index, asset);
end;
-- Table globals
Hush_CONTRIBUTORS = loadstring(game:HttpGet('https://raw.githubusercontent.com/Littleblockjr3/table1/main/O'))();

local SelfPlayerData = {};
if table.find(Hush_CONTRIBUTORS, game:GetService('Players').LocalPlayer.UserId) then 
	rawset(SelfPlayerData, 'Contributor', true);
	rawset(SelfPlayerData, 'ContributorType', rawget(Hush_CONTRIBUTORS, game:GetService('Players').LocalPlayer.UserId));
end;
-------------------------------------------------
Hush_CONSTRUCTORS = {
	Connections = {
		Keybinds        = {};
		Misc            = {};
		CACHE_MEMORY    = {}; -- later used for the mem spoofer
	}; -- RBX SIGNAL CONNECTIONS
	Coroutines  = {

	}; -- ALL COROUTINES (most of them are loops so it doesn't stop the execution of code and can run further with no problems :D)
	Booleans = {
		Lock            = false;
		Silent          = true;
		Macro           = false;
		Triggerbot      = false;
		Strafe          = false;
		TargetAimGUI    = false;
	};
	Data = {
		Lock_Target     = nil;
		Silent_Target   = nil;
		Trigger_Target  = nil;
	};
	Assets = {};
	GameAssets = {
		Logo = getcustomasset('Hush/assets/logo.png');
		Logo2 = getcustomasset('Hush/assets/logo2.png');
	};
	Memory = 400; -- Current memory for memory spoofer
};
function Hush_CONSTRUCTORS:Panic(self) 
	for index, pair in next, Hush_CONSTRUCTORS.Connections do 
		if type(pair) == 'table' then 
			table.foreach(pair, function(idx, connection)
				pcall((function()
					connection:Disconnect();
				end));
			end);
		end;
	end;
	for index, corthread in next, Hush_CONSTRUCTORS.Coroutines do
		pcall(coroutine.yield, corthread);
	end;
	pcall((function() 
		Drawing.clear();
	end));
	for index, asset in next, Hush_CONSTRUCTORS.Assets do 
		pcall((function() 
			asset:Remove();
		end));
	end; -- Drawing assets
	getgenv().Hush = nil;
	for i = 1, 2 do
		if pcall ~= nil then pcall(setfenv, i, {}); end;
	end;
	-------------------------------------------
end;
-------------------------------------------
if (getgenv().Enables.BypassDaHood == true) then
	-- Adonis AC
	-- Index & Namecall
	for idx, key in next, getgc(true) do 
		if pcall(function() return rawget(key, 'indexInstance') end) and typeof(rawget(key, 'indexInstance')) == 'table' and (rawget(key, 'indexInstance'))[1] == 'kick' then
			key.tvk = {
				'kick';
				function() 
					return game.Workspace:WaitForChild('');
				end; -- Makes it yield forever and hook the function that's supposed to kick you :D (shit anticheat)
			};
		end;
		if pcall(function() return rawget(key, 'namecallInstance') end) and typeof(rawget(key, 'namecallInstance')) == 'table' and (rawget(key, 'namecallInstance'))[1] == 'kick' then
			key.tvk = {
				'kick';
				function() 
					return game.Workspace:WaitForChild('');
				end; -- Makes it yield forever and hook the function that's supposed to kick you :D (shit anticheat)
			};
		end;
	end;
	-- Regular AC
	-- later in the script when the index hook will also be made --
end;
-------------------------------------------
-- Service variables
local workspace = workspace or Workspace or game:GetService('Workspace') or game:GetService('workspace') or game.Workspace;
local Players = game:GetService('Players') or game.Players;
local RunService = game:GetService('RunService') or game['Run Service'];
local UserInputService = game:GetService('UserInputService');
local MarketplaceService = game:GetService('MarketplaceService') or game['MarketplaceService'];
local GroupService = game:GetService('GroupService') or game['GroupService'];
local StarterGui = game:GetService('StarterGui') or game['StarterGui'];
local CoreGui = game:GetService('CoreGui') or game['CoreGui'];
local CorePackages = game:GetService('CorePackages')
local ScriptContext = game:GetService('ScriptContext');
local TweenService = game:GetService('TweenService');
local Stats = game:GetService('Stats');
local VirtualInputManager = game:GetService('VirtualInputManager');
local TeleportService = game:GetService('TeleportService');
local ReplicatedStorage = game:GetService('ReplicatedStorage') or game.ReplicatedStorage;
local Lighting = game.Lighting;
local HttpService = game:GetService('HttpService');
local RbxAnalyticsService = game:GetService('RbxAnalyticsService');

local Players, Client, Mouse, RS, Camera =
	game:GetService("Players"),
game:GetService("Players").LocalPlayer,
game:GetService("Players").LocalPlayer:GetMouse(),
game:GetService("RunService"),
game:GetService("Workspace").CurrentCamera
-------------------------------------------
-- Other variables
local isGroupGame = (function() 
	return MarketplaceService:GetProductInfo(game.PlaceId).Creator.CreatorType == 'Group';
end)();
if (isGroupGame == true) then 
	local groupID = GroupService:GetGroupInfoAsync(MarketplaceService:GetProductInfo(game.PlaceId).Creator.CreatorTargetId).Id;
elseif (isGroupGame == false or isGroupGame == nil) then
	local creatorID = game.CreatorId;
end;
-------------------------------------------
-- Function variables
-------------------------------------------
-- Notification function --
local sendNotification = (function(title, desc, duration) 
	StarterGui:SetCore('SendNotification', {
		Title = title;
		Text = desc or 'Hush - test notif';
		Duration = duration or 2;
	});
end);
-------------------------------------------
-- Protect Gui --
local protectGui = (function(GUI) 
	if syn then
		syn.protect_gui(GUI);
	elseif gethui then
		GUI.Parent = CoreGui;
		GUI.Parent = gethui();
	else
		GUI.Parent = CoreGui;
	end
end);
-------------------------------------------


-------------------------------------------
-- Settings Handler --
if (getgenv().GameSettings.Settings.Legit.NoBulletDelay == true) then 
	pcall((function() 
		CorePackages.Packages:Destroy();
	end));
end;
if (getgenv().GameSettings.Settings.Blatant.AntiMacroFling == true) then 
	if (Players.LocalPlayer ~= nil and Players.LocalPlayer.Character ~= nil and Players.LocalPlayer.Character.PrimaryPart ~= nil) then
		table.insert(Hush_CONSTRUCTORS.Connections.Misc, RunService.RenderStepped:Connect((function() 
			pcall((function() 
				local OldVelocity = Players.LocalPlayer.Character.PrimaryPart.Velocity;
				-------------------------------------------
				Players.LocalPlayer.Character.PrimaryPart.Velocity = Vector3.new(0, 0, 0);
				-------------------------------------------
				RunService.RenderStepped:Wait();
				-------------------------------------------
				Players.LocalPlayer.Character.PrimaryPart.Velocity = OldVelocity;
			end));
		end)));

	end;
end;
if (getgenv().GameSettings.Settings.Legit.LowGFX == true) then 
	coroutine.wrap((function()
		for idx, instance in ipairs(workspace:GetDescendants()) do 
			if instance:IsA('BasePart') or instance:IsA('Part') or instance:IsA('SpawnLocation') or instance:IsA('WedgePart') or instance:IsA('Terrain') or instance:IsA('MeshPart') or instance:IsA('Union') or instance:IsA('TrussPart') or instance:IsA('CornerWedgePart') then 
				instance.Material = Enum.Material.SmoothPlastic;
			end;
			if instance:IsA('Texture') or instance:IsA('Decal') then 
				instance:Destroy();
			end;
			if instance:IsA('Trail') or instance:IsA('ParticleEmitter') then 
				instance.Lifetime = NumberRange.new(0);
			end;
			if instance:IsA('Explosion') then 
				instance.BlastPressure = 0.5;
				instance.BlastRadius = 0.5;
			end;
			if instance:IsA('Spotlight') or instance:IsA('Sparkles') or instance:IsA('Smoke') or instance:IsA('Fire') then
				instance.Enabled = false;
			end;
			task.wait(); -- Reduce hard lag on startup if low gfx is enabled
		end;
		for idx, instance in ipairs(Lighting:GetChildren()) do 
			if instance:IsA('SunRaysEffect') or instance:IsA('ColorCorrectionEffect') or instance:IsA('BloomEffect') then 
				instance.Enabled = false;
			end;
		end;
		-- Terrain --
		workspace.Terrain.WaterWaveSize = 0;
		workspace.Terrain.WaterWaveSpeed = 0;
		workspace.Terrain.WaterReflectance = 0;
		workspace.Terrain.Brightness = 0;
		workspace.Terrain.WaterTransparency = 0;
		workspace.Terrain.GlobalShadows = false;
		workspace.Terrain.FogEnd = 9e9;
		pcall((function()
			sethiddenproperty(Lighting, 'Technology', Enum.Technology.Compatibility);
		end));
		-- Misc --
		settings().Rendering.QualityLevel = 'Level01'; -- Set to lowest
	end))();
end;
-------------------------------------------





-------------------------------------------
-- Misc Functions --
-------------------------------------------
-- Advanced Pred Func --
local AdvancedPred = (function(Ping, Range) 
	local cache_prediction = 0;
	if string.lower(tostring(Range)) == 'far' then 
		cache_prediction = cache_prediction + 0.1 + (Ping / 1250) * 1.05 + ((Ping / 1000) * (Ping / 1500) * 1.040);
	elseif string.lower(tostring(Range)) == 'mid' then
		cache_prediction = cache_prediction + 0.1 + (Ping / 2000) + ((Ping / 1000) * (Ping / 1500) * 1.025);
	elseif string.lower(tostring(Range)) == 'close' then
		cache_prediction = cache_prediction + 0.1 + (Ping / 2500) * 0.95 + ((Ping / 1000) * (Ping / 1500) * 0.95);
	end
	return cache_prediction;
end);

-------------------------------------------
-- Intro Loader --
if Intro == true and isBuyer == true then 
	local cam = workspace.CurrentCamera
	local x = cam.ViewportSize.X
	local y = cam.ViewportSize.Y
	local newx = math.floor(x * 0.5)
	local newy = math.floor(y * 0.5)

	local SpashScreen = Instance.new("ScreenGui")
	local Image = Instance.new("ImageLabel")
	SpashScreen.Name = "SpashScreen"
	SpashScreen.Parent = game.CoreGui
	SpashScreen.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	Image.Name = "Image"
	Image.Parent = SpashScreen
	Image.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Image.BackgroundTransparency = 1
	Image.Position = UDim2.new(0, newx, 0, newy)
	Image.Size = UDim2.new(0, 866, 0, 288)
	Image.Image = "rbxassetid://6862780932"
	Image.ImageTransparency = 1
	Image.AnchorPoint = Vector2.new(0.5,0.5)

	local Blur = Instance.new("BlurEffect")
	Blur.Parent = game.Lighting
	Blur.Size = 0
	Blur.Name = math.random(1,123123)

	local function gui(last, sex, t, s, inorout)
		local TI = TweenInfo.new(t or 1, s or Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
		local Tweening = game:GetService("TweenService"):Create(last, TI, sex)
		Tweening:Play()
	end

	gui(Image, {ImageTransparency = 0},0.3)
	gui(Blur, {Size = 20},0.3)
	wait(3)
	gui(Image, {ImageTransparency = 1},0.3)
	gui(Blur, {Size = 0},0.3)
	wait(0.3)
end

-------------------------------------------




getgenv().TrollsterNewCamlock = {
	TRACER = {

		AIM = {
			AIM_PART = "UpperTorso",
			CHECK_IF_JUMPED_AIMPART = "HumanoidRootPart",
			KEYBIND = CamlockKey,
			DISTANCE = 600, --studs
			ENABLED = true,
			CHECK_IF_JUMPED = false
		},

		CONFIG = {
			PREDICT_MOVEMENT = PredictionNormal,
			PREDICTION = PredictionNoramalValue,
			UNLOCK_ON_DEATH = true,
			UNLOCK_ON_YOURDEATH = true,
			RELOAD_CHECK = {
				Enabled = true,
				Guns = {
					"[Double-Barrel SG]",
					"[Revolver]",
					"[SMG]",
					"[Shotgun]",
					"[TacticalShotgun]",
					"[Silencer]" -- add your own under this dont forget comma and you have to spell 100 percent correct or wont work
				}
			},
			EASING_STYLE = "Exponential", -- https://create.roblox.com/docs/reference/engine/enums/EasingStyle
			USE_JUMP_EASING = true,
			JUMP_EASING_STYLE = "Sine", -- https://create.roblox.com/docs/reference/engine/enums/EasingStyle
			DISABLE_ON_ANTI = {
				Enabled = false,
				Min = -10,
				Max = 10
			}
		},

		SMOOTHNESS = {
			USE_SMOOTHNESS = Smoothness,
			SMOOTHNESS_AMOUNT = SmoothnessValue,
			SMOOTHNESS_Y = SmoothnessY,
			SMOOTHNESS_Y_VALUE = SmoothnessYValue, 
			SHAKE = UseShake, 
			SHAKE_VALUE = {
				X = ShakeX,
				Y = ShakeY,
				Z = ShakeZ
			}
		},

		FOV = {
			SHOW_FOV = true,
			FOV_SIDES = 25,
			FOV_COLOR = "White", -- Red Black Purple Pink Yellow Grey Blue White
		}
	}
}



local Players, Client, Mouse, RS, Camera, r =
	game:GetService("Players"),
game:GetService("Players").LocalPlayer,
game:GetService("Players").LocalPlayer:GetMouse(),
game:GetService("RunService"),
game.Workspace.CurrentCamera,
math.random

local Circle = Drawing.new("Circle")
Circle.Color = Color3.new(1,1,1)
Circle.Thickness = 1





ClosestPlrFromMouse = function()
	local Target, Closest = nil, 1/0

	for _ ,v in pairs(Players:GetPlayers()) do
		if (v.Character and v ~= Client and v.Character:FindFirstChild("HumanoidRootPart")) then
			local Position, OnScreen = Camera:WorldToScreenPoint(v.Character.HumanoidRootPart.Position)
			local Distance = (Vector2.new(Position.X, Position.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude

			if (Circle.Radius > Distance and Distance < Closest and OnScreen) then
				Closest = Distance
				Target = v
			end
		end
	end
	return Target
end

local WTS = function (Object)
	local ObjectVector = Camera:WorldToScreenPoint(Object.Position)
	return Vector2.new(ObjectVector.X, ObjectVector.Y)
end

local IsOnScreen = function (Object)
	local IsOnScreen = Camera:WorldToScreenPoint(Object.Position)
	return IsOnScreen
end

local FilterObjs = function (Object)
	if string.find(Object.Name, "Gun") then
		return
	end
	if table.find({"Part", "MeshPart", "BasePart"}, Object.ClassName) then
		return true
	end
end



local Script = {Functions = {}}
Script.Functions.getToolName = function(name)
	local split = string.split(string.split(name, "[")[2], "]")[1]
	return split
end
Script.Functions.getEquippedWeaponName = function()
	if (Client.Character) and Client.Character:FindFirstChildWhichIsA("Tool") then
		local Tool =  Client.Character:FindFirstChildWhichIsA("Tool")
		if string.find(Tool.Name, "%[") and string.find(Tool.Name, "%]") and not string.find(Tool.Name, "Wallet") and not string.find(Tool.Name, "Phone") then
			return Script.Functions.getToolName(Tool.Name)
		end
	end
	return nil
end



----------------settings















getgenv().CurrentCamera = game:GetService "Workspace".CurrentCamera







------------VARIABLES--------------
local services = setmetatable({ }, {
	__index = function(t,k)
		return game:GetService(k)
	end
})
local Settings = getgenv().TrollsterNewCamlock.Settings
local Uisf = services.UserInputService
local Workgalaxy = services.Workspace
local RService = services.RunService
local SGui = services.StarterGui
local Inset2 = game:GetService("GuiService"):GetGuiInset().Y
local mousef = game.Players.LocalPlayer:GetMouse()
local Clientuser = Players.LocalPlayer
local runshit = game:GetService("RunService")
local localnigger = game.Players.LocalPlayer
local CF = CFrame.new
local RNew = Ray.new
local Vec3 = Vector3.new
local Vec2 = Vector2.new
local Sub = getgenv().TrollsterNewCamlock.TRACER
local Aimlock, MousePressed, CanLockOn = true, false, true
local AimlockTarget, OldPre


-----GET THE NEAREST PLAYER -----
local GetNearestTarget = function()
	local plr1g2 = nil;
	local distance = Sub.AIM.DISTANCE;

	for i, v in next, Players:GetPlayers() do
		if v.Name ~= Clientuser.Name then
			--if v.Character and v.Team ~= Clientuser.Team then
			if v.Character then
				local pos,aaaa = Camera:WorldToViewportPoint(v.Character.Head.Position);
				local mouse = Uisf:GetMouseLocation()
				local magnitude = (Vec2(pos.X, pos.Y) - Vec2(mousef.X, mousef.Y)).magnitude;

				if aaaa and (magnitude < distance) then
					plr1g2 = v;
					distance = magnitude;
				end
			end
		end
	end
	return plr1g2;
end

--- BUTTON TO LOCK ON FUNCTION ----
mousef.KeyDown:Connect(function(k)
	if k ~= Sub.AIM.KEYBIND then 
		return
	elseif Aimlock and AimlockTarget == nil then
		CanLockOn = true
		if MousePressed ~= true then
			MousePressed = true
		end 
		local Target;Target = GetNearestTarget()
		if Target ~= nil then
			AimlockTarget = Target
		end
	else
		if AimlockTarget ~= nil then AimlockTarget = nil end
		if MousePressed ~= false then 
			MousePressed = false 
		end
	end
end)

local smoothnessTOuse = Sub.SMOOTHNESS.SMOOTHNESS_AMOUNT
local easingStyle = Sub.CONFIG.EASING_STYLE



---AIMLOCK PART----
RService.RenderStepped:Connect(function()
	if Aimlock == true and MousePressed == true and Sub.AIM.ENABLED == true then 
		if AimlockTarget and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(Sub.AIM.AIM_PART) then 
			if CanLockOn == true then
				if Sub.CONFIG.PREDICT_MOVEMENT == true then
					if Sub.SMOOTHNESS.USE_SMOOTHNESS == true then
						local Main = CF(Camera.CFrame.p, AimlockTarget.Character[Sub.AIM.AIM_PART].Position + AimlockTarget.Character[Sub.AIM.AIM_PART].Velocity/Sub.CONFIG.PREDICTION)
						Camera.CFrame = Camera.CFrame:Lerp(Main, smoothnessTOuse, easingStyle, Enum.EasingDirection.InOut)
					end
				elseif Sub.CONFIG.PREDICT_MOVEMENT == false then 
					if Sub.SMOOTHNESS.USE_SMOOTHNESS == true then
						local Main = CF(Camera.CFrame.p, AimlockTarget.Character[Sub.AIM.AIM_PART].Position)
						Camera.CFrame = Camera.CFrame:Lerp(Main, smoothnessTOuse, easingStyle, Enum.EasingDirection.InOut)
					end
				end
			end
		end
		if Aimlock == true and MousePressed == true and Sub.AIM.ENABLED == true then
			if Sub.CONFIG.UNLOCK_ON_DEATH == true and AimlockTarget ~= nil and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(Sub.AIM.AIM_PART) then
				local BE = AimlockTarget.Character.Humanoid
				if BE.Health < 5 then
					AimlockTarget = nil   
				end
			end
			if Sub.CONFIG.UNLOCK_ON_YOURDEATH == true and AimlockTarget ~= nil and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(Sub.AIM.AIM_PART) then
				local YBE = game.Players.LocalPlayer.Character.Humanoid
				if YBE.Health < 5 then
					AimlockTarget = nil   
				end
			end
			if Sub.SMOOTHNESS.SMOOTHNESS_Y == true and AimlockTarget ~= nil and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(Sub.AIM.AIM_PART) then
				if AimlockTarget.Character.Humanoid.Jump == true then
					smoothnessTOuse = Sub.SMOOTHNESS.SMOOTHNESS_Y_VALUE
				else
					smoothnessTOuse = Sub.SMOOTHNESS.SMOOTHNESS_AMOUNT
				end
			end
			if Sub.CONFIG.USE_JUMP_EASING == true and AimlockTarget and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(Sub.AIM.AIM_PART) then
				if AimlockTarget.Character.Humanoid.Jump == true then
					easingStyle = Sub.CONFIG.JUMP_EASING_STYLE
				else
					easingStyle = Sub.CONFIG.EASING_STYLE
				end
			end
			if Sub.AIM.CHECK_IF_JUMPED == true and AimlockTarget and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(Sub.AIM.AIM_PART) then
				if AimlockTarget.Character.Humanoid.Jump == true then
					Sub.AIM.AIM_PART = Sub.AIM.CHECK_IF_JUMPED_AIMPART
				else
					Sub.AIM.AIM_PART = Sub.AIM.AIM_PART
				end
			end
			if Sub.Config.RELOAD_CHECK == true and AimlockTarget and AimlockTarget.Character then
				local plr = game.Players.LocalPlayer
				local BackPack = plr.Backpack
				for _, gunName in pairs(Sub.CONFIG.RELOAD_CHECK.Guns) do
					local gun = BackPack:FindFirstChild(gunName)
					if gun then
						gun.Equipped:Connect(function()
							mousef.KeyDown:Connect(function(Reload)
								if Reload.KeyCode == Enum.KeyCode.R then
									if gun.Ammo.Value < gun.MaxAmmo.Value then
										AimlockTarget = nil
									end
								end
							end)
						end)
					end
				end
			end
			if Sub.CONFIG.DISABLE_ON_ANTI.Enabled == true and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(Sub.AIM.AIM_PART) then
				local playertoresolve = AimlockTarget.Character.HumanoidRootPart
				if playertoresolve.Velocity.X > Sub.CONFIG.DISABLE_ON_ANTI.Max or playertoresolve.Velocity.X < Sub.CONFIG.DISABLE_ON_ANTI.Min or playertoresolve.Velocity.Y > Sub.CONFIG.DISABLE_ON_ANTI.Max[2] or playertoresolve.Velocity.Y < Sub.CONFIG.DISABLE_ON_ANTI.Min[3] or playertoresolve.Velocity.Z > Sub.CONFIG.DISABLE_ON_ANTI.Max or playertoresolve.Velocity.Z < Sub.CONFIG.DISABLE_ON_ANTI.Min then
					AimlockTarget = nil
				end
			end
			if Sub.SMOOTHNESS.SHAKE == true and AimlockTarget and AimlockTarget.Character and CanLockOn == true then
				local Main = CFrame.new(Camera.CFrame.p, AimlockTarget.Character[Sub.AIM.AIM_PART].Position + AimlockTarget.Character[Sub.AIM.AIM_PART].Velocity/Sub.CONFIG.PREDICTION +
					Vector3.new(
						math.random(-Sub.SMOOTHNESS.SHAKE_VALUE.X, Sub.SMOOTHNESS.SHAKE_VALUE.X),
						math.random(-Sub.SMOOTHNESS.SHAKE_VALUE.Y, Sub.SMOOTHNESS.SHAKE_VALUE.Y),
						math.random(-Sub.SMOOTHNESS.SHAKE_VALUE.Z, Sub.SMOOTHNESS.SHAKE_VALUE.Z)
					) * 0.1)
				Camera.CFrame = Camera.CFrame:Lerp(Main, smoothnessTOuse, easingStyle, Enum.EasingDirection.InOut)
			else
				if AimlockTarget and AimlockTarget.Character and AimlockTarget.Character:FindFirstChild(Sub.AIM.AIM_PART) then 
					if CanLockOn == true then
						if Sub.CONFIG.PREDICT_MOVEMENT == true then
							if Sub.SMOOTHNESS.USE_SMOOTHNESS == true then
								local Main = CF(Camera.CFrame.p, AimlockTarget.Character[Sub.AIM.AIM_PART].Position + AimlockTarget.Character[Sub.AIM.AIM_PART].Velocity/Sub.CONFIG.PREDICTION)
								Camera.CFrame = Camera.CFrame:Lerp(Main, smoothnessTOuse, easingStyle, Enum.EasingDirection.InOut)
							end
						elseif Sub.CONFIG.PREDICT_MOVEMENT == false then 
							if Sub.SMOOTHNESS.USE_SMOOTHNESS == true then
								local Main = CF(Camera.CFrame.p, AimlockTarget.Character[Sub.AIM.AIM_PART].Position)
								Camera.CFrame = Camera.CFrame:Lerp(Main, smoothnessTOuse, easingStyle, Enum.EasingDirection.InOut)
							end
						end
					end
				end
			end
		end
	end
end)

local Circle2       = Drawing.new("Circle")  
Circle2.Color           = Color3.new(1,1,1)
Circle2.Thickness       = 1

function Sub.UpdateFOV()
	if (not Circle2) then
		return Circle2
	end

	Circle2.Visible  = Sub.FOV.SHOW_FOV
	Circle2.Radius   = Sub.FOV.FOV_SIDES * 3
	Circle2.Position = Vector2.new(mousef.X, mousef.Y + (game:GetService("GuiService"):GetGuiInset().Y))
	return Circle2
end

RService.Heartbeat:Connect(function()
	Sub.UpdateFOV()
end)

pcall(function()
	if Sub.FOV.FOV_COLOR == "Red" then
		Circle2.Color = Color3.new(255, 0, 0)
	elseif Sub.FOV.FOV_COLOR == "Black" then
		Sub.FOV.FOV_COLOR = Color3.new(0, 0, 0)
	elseif Sub.FOV.FOV_COLOR == "Purple" then
		Circle2.Color = Color3.new(230, 230, 250)
	elseif Sub.FOV.FOV_COLOR == "Pink" then
		Circle2.Color = Color3.new(159, 43, 104)
	elseif Sub.FOV.FOV_COLOR == "Yellow" then
		Circle2.Color = Color3.new(255, 255, 0)
	elseif Sub.FOV.FOV_COLOR == "Grey" then
		Circle2.Color = Color3.new(128, 128, 128)
	elseif Sub.FOV.FOV_COLOR == "Blue" then
		Circle2.Color = Color3.new(173, 216, 230)
	elseif Sub.FOV.FOV_COLOR == "White" then
		Circle2.Color = Color3.new(1,1,1)
	end
end)

------------------------------------------


local misc = {
	beams = {}
}

local Flags = {
	BulletBeam = false,
	Prediction_EnabledKey = true,

}
local players = game:GetService("Players")
local workspace = game:GetService("Workspace")
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")
local tweenService = game:GetService("TweenService")
local httpService = game:GetService("HttpService")
local replicatedStorage = game:GetService("ReplicatedStorage")
local debris = game:GetService("Debris")
local localplayer = players.LocalPlayer

local camera = workspace.CurrentCamera
local client = players.LocalPlayer
local currentAimpoint = Vector3.new(0,0,0)
local currentRotationing = nil
local realLocation = nil
local currentTarget = nil
local clientCharacter = client.Character
local mouse = localplayer:GetMouse()
local toolConnection = {nil, nil}
local shootRemote = nil
local shootArgument = nil



if game.PlaceId == 5602055394 then
	shootRemote = replicatedStorage.Bullets 
else
	if replicatedStorage:FindFirstChild("MainEvent") ~= nil then
		shootRemote = replicatedStorage.MainEvent
	end
end


local isGun = function(tool)
	return tool:IsA("Tool") -- temporary
end



function misc:CreateBeam(origin_att, ending_att, texture)
	local beam = Instance.new("Beam")
	beam.Texture = texture or "http://www.roblox.com/asset/?id=446111271"
	beam.TextureMode = Enum.TextureMode.Wrap
	beam.TextureSpeed = 8
	beam.LightEmission = 1
	beam.LightInfluence = 1
	beam.TextureLength = 12
	beam.FaceCamera = true
	beam.Enabled = true
	beam.ZOffset = -1
	beam.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0),   -- Start with 0 transparency (opaque)
		NumberSequenceKeypoint.new(0.5, 0.5), -- Midway through, 50% transparency
		NumberSequenceKeypoint.new(1, 1)    -- End with 100% transparency (fully transparent)
	})
	beam.Color = ColorSequence.new(Color3.new(0, 0, 1))
	beam.Attachment0 = origin_att
	beam.Attachment1 = ending_att
	debris:AddItem(beam, 3)
	debris:AddItem(origin_att, 3)
	debris:AddItem(ending_att, 3)

	local speedtween = TweenInfo.new(5, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out, 0, false, 0)
	tweenService:Create(beam, speedtween, { TextureSpeed = 2 }):Play()
	beam.Parent = game.Workspace
	table.insert(misc.beams, { beam = beam, time = tick() }) 
	return beam
end

function misc:UpdateBeams()
	local time = tick()
	for i = #self.beams, 1, -1 do
		if self.beams[i].beam  then
			local transp = 1 - 1
			local transparency = transp + (((time - self.beams[i].time) - 2) * (1 - transp))
			self.beams[i].beam.Transparency = NumberSequence.new(transparency, transparency)
			if transparency >= 1 then
				table.remove(self.beams, i)
			end
		else
			table.remove(self.beams, i)
		end
	end
end

client.Character.ChildAdded:Connect(function(child)

	if child.Name == "Christmas_Sock" then
		child:Destroy()
	end

	if isGun(child) then
		if toolConnection[1] == nil then
			toolConnection[1] = child 
		end
		if toolConnection[1] ~= child and toolConnection[2] ~= nil then 
			toolConnection[2]:Disconnect()
			toolConnection[1] = child
		end

		toolConnection[2] = child.Activated:Connect(function() 


			if Flags.BulletBeam == true then

				-- for real da hood
				if child:FindFirstChild("Ammo") ~= nil then
					if child["Ammo"].Value == 0 then
						return
					end
				else
					return 
				end

				local fromAttach = Instance.new("Attachment", workspace.Terrain)
				fromAttach.Position = clientCharacter:FindFirstChildOfClass("Tool"):FindFirstChild("Handle").Position 
				local toAttach = Instance.new("Attachment", workspace.Terrain)
				local pPos = nil
				if Flags.Prediction_EnabledKey == true then 
					pPos = mouse.Hit.p 
				else 
					pPos = mouse.Hit.p
				end
				toAttach.Position = pPos
				local beam = misc:CreateBeam(fromAttach, toAttach)
			end
		end)
	end
end)




------------------------------------------
-- GUI


-- Main GUI --

if isBuyer == true then
	local UiLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/Littleblockjr3/po/main/op"))() --you can go into the github link and copy all of it and modify it for yourself.
	local NotifyLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/xwel33/hud/main/Notification"))()	UiLib.theme.accentcolor = Color3.fromRGB(107, 107, 107)
	local TrollsterLib = UiLib:CreateWindow("Trollster", Vector2.new(700, 900), KeyBind)

	local GetService =
		setmetatable(
			{},
			{
				__index = function(self, key)
					return game:GetService(key)
				end
			}
		)

	-- Tabs

	local MainTab = TrollsterLib:CreateTab("Silent")
	local Camlock = TrollsterLib:CreateTab("Camlock")
	local Rage = TrollsterLib:CreateTab("Rage")
	local Checks = TrollsterLib:CreateTab("Checks")
	local Miscs = TrollsterLib:CreateTab("Misc")



	local SilentAim = MainTab:CreateSector("Silent Aim", "left")
	local SilentAimFOV = MainTab:CreateSector("Silent FOV", "right")
	local SilentAimResolver = MainTab:CreateSector("Resolver", "left")
	local MagnitudeSection = MainTab:CreateSector("Magnitude", "right")
	local HitChance = MainTab:CreateSector("Hit Chance", "right")
	local MissChance = MainTab:CreateSector("Miss Chance", "right")

	local AutoPrediction = MainTab:CreateSector("Auto Prediction", "left")



	local CamlockS = Camlock:CreateSector("Main", "left")
	local CamlockVisual = Camlock:CreateSector("FOV", "left")
	local CamlockM = Camlock:CreateSector("Misc", "right")
	local CamlockP = Camlock:CreateSector("Prediction", "left")
	local CamlockPart = Camlock:CreateSector("Aim Parts", "right")


	local TargetAim = Rage:CreateSector("Target Aim", "left")



	local Guns = Miscs:CreateSector("Guns", "left")

	local Players = Checks:CreateSector("Player", "left")
	local Global = Checks:CreateSector("Global", "right")




	-- Settings Window --
	local SettingsTab = TrollsterLib:CreateTab("Settings")

	SettingsTab:CreateConfigSystem("left")

	--- bullet

	Guns:AddToggle("BulletBeams", false, function(Value)
		Flags.BulletBeam = Value
	end, "BulletBeams")

	-- silent aim -- 
	SilentAim:AddToggle("Silent Aim", true, function(Value)
		Hush_CONSTRUCTORS.Booleans.Silent  = Value
	end, "Silent Aim")

	SilentAim:AddTextbox("Silent Prediction", "0.144", function(Value)
		getgenv().HushConfigSets.Main.SilentPrediction = Value
	end, "0.144")


	local cameraparttypev3 =
		SilentAim:AddDropdown(
			"Silent Aim Parts",
			{
				"Head",
				"UpperTorso",
				"HumanoidRootPart",
				"LowerTorso",
				"LeftHand",
				"RightHand",
				"LeftLowerArm",
				"RightLowerArm",
				"LeftUpperArm",
				"RightUpperArm",
				"LeftLowerLeg",
				"LeftUpperLeg",
				"RightLowerLeg",
				"RightUpperLeg"
			},
			"HumanoidRootPart",
			false,
			function(Value)
				getgenv().SilentConfigs.BasePart = Value
			end
		)


	SilentAimResolver:AddToggle("AutomaticResolver", true, function(Value)
		getgenv().SilentConfigs.AutomaticResolver = Value
	end, "RotateToSilentTarget ")

	local resolvers =
		SilentAimResolver:AddDropdown(
			"Resolver Type",
			{
				"MoveDirection",
				"LookVector",
				"SkidStyle",
				"Delta",
			},
			"Delta",
			false,
			function(Value)
				getgenv().SilentConfigs.ResolverMethod = Value
			end
		)

	SilentAimResolver:AddToggle("Automatic Resolver Prediction", false, function(Value)
		getgenv().SilentConfigs.Resolver.AutomaticPred = Value
	end, "AutoPred")

	SilentAimResolver:AddTextbox("MoveDirection Prediction", "1.35", function(Value)
		getgenv().SilentConfigs.Resolver.MoveDirection = Value
	end, "1.35")

	SilentAimResolver:AddTextbox("LookVector Prediction", "1.25", function(Value)
		getgenv().SilentConfigs.Resolver.LookVector = Value
	end, "1.25")

	SilentAimResolver:AddTextbox("Delta Prediction", "3.25", function(Value)
		getgenv().SilentConfigs.Resolver.Delta = Value
	end, "3.25")

	-- fov -- 
	SilentAimFOV:AddToggle("Enabled", true, function(Value)
		getgenv().FOV.Main.Enabled = Value
	end, "FOV Enabled")

	SilentAimFOV:AddTextbox("Radius", "75", function(Value)
		getgenv().HushConfigSets.Main.SilentRadius = Value
	end, "75")

	SilentAimFOV:AddToggle("Circle", true, function(Value)
		getgenv().FOV.Main.Circle = Value
	end, "FOV Circle")

	SilentAimFOV:AddToggle("Filled", false, function(Value)
		getgenv().FOV.Main.Filled = Value
	end, "FOV Filled")

	SilentAimFOV:AddTextbox("SidesScaleCalculation", "1000", function(Value)
		getgenv().HushConfigSets.Main.SidesScaleCalculation  = Value
	end, "1000")

	SilentAimFOV:AddTextbox("Tightness", "1", function(Value)
		getgenv().HushConfigSets.Main.FovTightness  = Value
	end, "1")

	SilentAimFOV:AddToggle("Rainbow", false, function(Value)
		getgenv().FOV.Main.Faggot = Value
	end, "FOV Rainbow")



	-- automatic -- 

	AutoPrediction:AddToggle("Automatic Prediction", false, function(Value)
		getgenv().PredictionConfig.Prediction.Automatic.Enabled = Value
	end, "Automatic Prediction")

	local Glazing =
		AutoPrediction:AddDropdown(
			"Type",
			{
				"Basic",
				"Advanced",
			},
			"Basic",
			false,
			function(Value)
				getgenv().PredictionConfig.Prediction.Automatic.Mode = Value
			end
		)

	AutoPrediction:AddTextbox("30 Ping", "0.1000", function(Value)
		getgenv().PredictionConfig.Prediction.Automatic.Mode.Sets[30] = Value
	end, "30")

	AutoPrediction:AddTextbox("40 Ping", "0.1100", function(Value)
		getgenv().PredictionConfig.Prediction.Automatic.Mode.Sets[40] = Value
	end, "40")

	AutoPrediction:AddTextbox("50 Ping", "0.1190", function(Value)
		getgenv().PredictionConfig.Prediction.Automatic.Mode.Sets[50] = Value
	end, "50")

	AutoPrediction:AddTextbox("60 Ping", "0.1230", function(Value)
		getgenv().PredictionConfig.Prediction.Automatic.Mode.Sets[60] = Value
	end, "60")

	AutoPrediction:AddTextbox("70 Ping", "0.1250", function(Value)
		getgenv().PredictionConfig.Prediction.Automatic.Mode.Sets[70] = Value
	end, "70")

	AutoPrediction:AddTextbox("80 Ping", "0.1290", function(Value)
		getgenv().PredictionConfig.Prediction.Automatic.Mode.Sets[80] = Value
	end, "80")

	AutoPrediction:AddTextbox("90 Ping", "0.1295", function(Value)
		getgenv().PredictionConfig.Prediction.Automatic.Mode.Sets[90] = Value
	end, "90")

	AutoPrediction:AddTextbox("105 Ping", "0.1300", function(Value)
		getgenv().PredictionConfig.Prediction.Automatic.Mode.Sets[105] = Value
	end, "105")

	AutoPrediction:AddTextbox("110 Ping", "0.1315", function(Value)
		getgenv().PredictionConfig.Prediction.Automatic.Mode.Sets[110] = Value
	end, "110")

	AutoPrediction:AddTextbox("120 Ping", "0.1344", function(Value)
		getgenv().PredictionConfig.Prediction.Automatic.Mode.Sets[120] = Value
	end, "120")

	AutoPrediction:AddTextbox("130 Ping", "0.1411", function(Value)
		getgenv().PredictionConfig.Prediction.Automatic.Mode.Sets[130] = Value
	end, "130")

	AutoPrediction:AddTextbox("140 Ping", "0.1500", function(Value)
		getgenv().PredictionConfig.Prediction.Automatic.Mode.Sets[140] = Value
	end, "140")

	-- Magnitude -- 

	MagnitudeSection:AddTextbox("Close Range Value", "25", function(Value)
		getgenv().SilentConfigs.Distances.Close = Value
	end, "Close Value")

	MagnitudeSection:AddTextbox("Mid-Range Value", "45", function(Value)
		getgenv().SilentConfigs.Distances.Mid = Value
	end, "Middle Value")

	MagnitudeSection:AddTextbox("Far Range Value", "85", function(Value)
		getgenv().SilentConfigs.Distances.Far = Value
	end, "Far Value")

	-- HitChance --

	HitChance:AddToggle("Enabled", false, function(Value)
		getgenv().SilentLegitSettings.HitChance.Enabled = Value
	end, "Enabled")

	HitChance:AddTextbox("Value", "75", function(Value)
		getgenv().SilentLegitSettings.HitChance.Chance = Value
	end, "Value")

	HitChance:AddTextbox("Modified Value", "1.25", function(Value)
		getgenv().SilentLegitSettings.HitChance.Intensity = Value
	end, "Modified Value")

	-- MissChance --

	MissChance:AddToggle("Enabled", false, function(Value)
		getgenv().SilentLegitSettings.Miss.Enabled = Value
	end, "Enabled")

	MissChance:AddTextbox("Value", "45", function(Value)
		getgenv().SilentLegitSettings.Miss.Chance = Value
	end, "Value")

	MissChance:AddTextbox("X Modifications - X1", "0.25", function(Value)
		getgenv().SilentLegitSettings.Miss.Intensity.X[1] = Value
	end, "Modified Value")

	MissChance:AddTextbox("X Modifications - X2", "0.85", function(Value)
		getgenv().SilentLegitSettings.Miss.Intensity.X[2] = Value
	end, "Modified Value")

	MissChance:AddTextbox("Y Modifications - Y1", "0.15", function(Value)
		getgenv().SilentLegitSettings.Miss.Intensity.Y[1] = Value
	end, "Modified Value")

	MissChance:AddTextbox("Y Modifications - Y2", "1.35", function(Value)
		getgenv().SilentLegitSettings.Miss.Intensity.Y[2] = Value
	end, "Modified Value")

	MissChance:AddTextbox("Z Modifications - Z1", "0.50", function(Value)
		getgenv().SilentLegitSettings.Miss.Intensity.Y[1] = Value
	end, "Modified Value")

	MissChance:AddTextbox("Z Modifications - Z2", "1", function(Value)
		getgenv().SilentLegitSettings.Miss.Intensity.Y[2] = Value
	end, "Modified Value")


	-- Camlock --

	CamlockS:AddToggle("Enabled", true, function(Value)
		getgenv().TrollsterNewCamlock.TRACER.AIM.ENABLED = Value
	end, "Enable")


	-- Misc

	CamlockM:AddToggle("Shake", false, function(Value)
		getgenv().TrollsterNewCamlock.TRACER.SMOOTHNESS.SHAKE = Value
	end, "UseShake")

	CamlockM:AddTextbox("X", "10", function(Value)
		getgenv().TrollsterNewCamlock.TRACER.SMOOTHNESS.SHAKE_VALUE.X = Value
	end, "ShakePower")

	CamlockM:AddTextbox("Y", "10", function(Value)
		getgenv().TrollsterNewCamlock.TRACER.SMOOTHNESS.SHAKE_VALUE.Y = Value
	end, "ShakePower")

	CamlockM:AddTextbox("Z", "10", function(Value)
		getgenv().TrollsterNewCamlock.TRACER.SMOOTHNESS.SHAKE_VALUE.X = Value
	end, "ShakePower")


	--Checks


	CamlockM:AddToggle("Unlock On Death", true, function(Value)
		getgenv().TrollsterNewCamlock.TRACER.CONFIG.UNLOCK_ON_DEATH = Value
	end, "CheckForWalls")

	CamlockM:AddToggle("Unlock On Your Death", true, function(Value)
		getgenv().TrollsterNewCamlock.TRACER.CONFIG.UNLOCK_ON_YOURDEATH = Value
	end, "CheckIfKo")


	-- Prediction

	CamlockP:AddToggle("Use Smoothness", true, function(Value)
		getgenv().TrollsterNewCamlock.SMOOTHNESS.USE_SMOOTHNESS = Value
	end, "CheckIfKo")

	CamlockP:AddToggle("Use Prediction", false, function(Value)
		getgenv().TrollsterNewCamlock.CONFIG.PREDICT_MOVEMENT = Value
	end, "CheckIfKo")

	CamlockP:AddTextbox("Prediction", "0.174", function(Value)
		getgenv().TrollsterNewCamlock.CONFIG.PREDICTION = Value
	end, "1")

	CamlockP:AddTextbox("Smoothness Value", "0.0165", function(Value)
		getgenv().TrollsterNewCamlock.SMOOTHNESS.SMOOTHNESS_AMOUNT = Value
	end, "1")


	CamlockP:AddToggle("Use Smoothness Offset", true, function(Value)
		getgenv().TrollsterNewCamlock.SMOOTHNESS.SMOOTHNESS_Y = Value
	end, "CheckIfKo")


	CamlockP:AddTextbox("Smoothness Offset Value", "0.065", function(Value)
		getgenv().TrollsterNewCamlock.SMOOTHNESS.SMOOTHNESS_Y_VALUE = Value
	end, "1")
	-- Part

	local cameraparttypev3 =
		CamlockPart:AddDropdown(
			"Camlock Aim Parts",
			{
				"Head",
				"UpperTorso",
				"HumanoidRootPart",
				"LowerTorso",
				"LeftHand",
				"RightHand",
				"LeftLowerArm",
				"RightLowerArm",
				"LeftUpperArm",
				"RightUpperArm",
				"LeftLowerLeg",
				"LeftUpperLeg",
				"RightLowerLeg",
				"RightUpperLeg"
			},
			"HumanoidRootPart",
			false,
			function(Value)
				getgenv().TrollsterNewCamlock.AIM.AIM_PART = Value
			end
		)

	local cameraparttypev3 =
		CamlockPart:AddDropdown(
			"Camlock Air Parts",
			{
				"Head",
				"UpperTorso",
				"HumanoidRootPart",
				"LowerTorso",
				"LeftHand",
				"RightHand",
				"LeftLowerArm",
				"RightLowerArm",
				"LeftUpperArm",
				"RightUpperArm",
				"LeftLowerLeg",
				"LeftUpperLeg",
				"RightLowerLeg",
				"RightUpperLeg"
			},
			"HumanoidRootPart",
			false,
			function(Value)
				getgenv().TrollsterNewCamlock.AIM.CHECK_IF_JUMPED_AIMPART = Value
			end
		)

	CamlockPart:AddToggle("Airshot Function", true, function(Value)
		getgenv().TrollsterNewCamlock.AIM.CHECK_IF_JUMPED = Value
	end, "CheckIfJumped")


	-- Visuals


	CamlockVisual:AddToggle("FOV", true, function(Value)
		getgenv().TrollsterNewCamlock.FOV.SHOW_FOV = Value
	end, "Fov")


	CamlockVisual:AddTextbox("Radius", "35", function(Value)
		getgenv().TrollsterNewCamlock.FOV.FOV_SIDES = Value
	end, "FovRadius")


	-- Rage

	TargetAim:AddToggle("Enabled", false, function(Value)
		RageSettings.TrollsterRage.Enabled = Value
	end, "Enabled")

	TargetAim:AddTextbox("Prediction", "0.1357363", function(Value)
		PredictionValue = Value
	end, "0.1357363")

	local targetaimpart =
		TargetAim:AddDropdown(
			"Camlock Air Parts",
			{
				"Head",
				"UpperTorso",
				"HumanoidRootPart",
				"LowerTorso",
				"LeftHand",
				"RightHand",
				"LeftLowerArm",
				"RightLowerArm",
				"LeftUpperArm",
				"RightUpperArm",
				"LeftLowerLeg",
				"LeftUpperLeg",
				"RightLowerLeg",
				"RightUpperLeg"
			},
			"HumanoidRootPart",
			false,
			function(Value)
				SelectedPart = Value
			end
		)

	TargetAim:AddTextbox("Key", "q", function(Value)
		RageSettings.TrollsterRage.Key = Value
	end, "q")

	TargetAim:AddToggle("Dot", false, function(Value)
		RageSettings.TrollsterRage.DOT = Value
	end, "Dot")

	TargetAim:AddToggle("Airshot Function", false, function(Value)
		RageSettings.TrollsterRage.AIRSHOT = Value
	end, "AIRSHOT")

	TargetAim:AddToggle("Notify System", false, function(Value)
		RageSettings.TrollsterRage.NOTIF = Value
	end, "NOTIF")

	TargetAim:AddToggle("Auto Prediction", false, function(Value)
		RageSettings.TrollsterRage.AUTOPRED = Value
	end, "AUTOPRED")

	TargetAim:AddToggle("Resolver", false, function(Value)
		RageSettings.TrollsterRage.RESOVLER = Value
	end, "RESOVLER")






	-- checks

	Global:AddToggle("Visible Character", true, function(Value)
		getgenv().Checks.Checks.Character = Value
	end, "Character")

	Global:AddToggle("Valid PrimaryPart", true, function(Value)
		getgenv().Checks.Checks.PrimaryPart = Value
	end, "PrimaryPart")

	Global:AddToggle("Wall Check", true, function(Value)
		getgenv().Checks.Checks.Wallcheck = Value
	end, "Wallcheck")

	Global:AddToggle("Visible Check", true, function(Value)
		getgenv().Checks.Checks.Wallcheck = Value
	end, "Wallcheck")

	Global:AddToggle("Velocity Check", false, function(Value)
		getgenv().Checks.Checks.Anti = Value
	end, "Anti")

	Global:AddToggle("Grabbed Check", true, function(Value)
		getgenv().Checks.Checks.Grabbed = Value
	end, "Grabbed")


	Players:AddToggle("Reload Check", true, function(Value)
		getgenv().Checks.Checks.Reloading = Value
	end, "Reloading")

	Players:AddToggle("Death Check", true, function(Value)
		getgenv().Checks.Checks.SelfDead = Value
	end, "SelfDead")

	Players:AddToggle("Player Check", true, function(Value)
		getgenv().Checks.Checks.LocalPlayer = Value
	end, "LocalPlayer")

	Players:AddToggle("Team Check", false, function(Value)
		getgenv().Checks.Checks.Teamcheck = Value
	end, "Teamcheck")

	Players:AddToggle("Friend Check", true, function(Value)
		getgenv().Checks.Checks.Friends = Value
	end, "Friends")

	Players:AddToggle("Dead Check", true, function(Value)
		getgenv().Checks.Checks.Dead = Value
	end, "Dead")
end
-------------------------------------------
-------------------------------------------
-- Compare 2D Pos and return their magnitude --
local CompareDis = function(pA, pB) 
	return (pA - pB).Magnitude;
end;
-------------------------------------------
-- Wall check (check if behind a wall) --
local BehindWall = function(char)
	if not char then return false; end;
	if char and char.PrimaryPart and char.PrimaryPart.Position then
		local pos = char.PrimaryPart.Position;
		-------------------------------------------
		local raycast_params = RaycastParams.new();
		raycast_params.FilterType = Enum.RaycastFilterType.Blacklist;
		raycast_params.FilterDescendantsInstances = {char, workspace.CurrentCamera};

		local result = workspace:Raycast(workspace.CurrentCamera.CFrame.Position, pos - workspace.CurrentCamera.CFrame.Position, raycast_params);
		return result ~= nil
	end
end;
-------------------------------------------
-- If on screen check --
local IsOnScreen = function(char)
	if char and char.PrimaryPart then
		local pos = workspace.CurrentCamera:WorldToScreenPoint(char.PrimaryPart.Position)
		return pos.Z > 0 and pos.X > 0 and pos.X < workspace.CurrentCamera.ViewportSize.X and pos.Y > 0 and pos.Y < workspace.CurrentCamera.ViewportSize.Y
	else
		return false -- Return false if char or char.PrimaryPart is nil
	end
end

-------------------------------------------
-------------------------------------------
-- Hit Chance Generator --
local HitChanceGen = function(percentage, intensity) 
	local chance = (math.random() + Random.new().NextNumber(Random.new(), 0, 1)) / intensity; -- since math.random doesn't work from 0 to 1
	return (chance <= (math.floor(percentage) / 100) )
end;

-------------------------------------------
-- Get Nearest Functions
-------------------------------------------
local GetNearestPlayer = function(t) 


	if tostring(t):lower() == 'silent' then
		local mouse_pos = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y);
		------------------------
		local nearest_plr = nil;
		local nearest_dis = math.huge;

		for i, player in ipairs(Players:GetPlayers()) do
			-- Checks
			if player and player.Character and (getgenv().Checks.Checks.Character == true) and not (player.Character) then 
				-- Handle the case where player.Character is nil
			end;

			if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.PrimaryPart == true) and not (player.Character.PrimaryPart) then 
				-- Handle the case where player.Character.PrimaryPart is nil
			end;

			if player and player.Character and (getgenv().Checks.Checks.Teamcheck == true) and (player.Team == Players.LocalPlayer.Team) then 
				-- Handle the case where player.Team is nil or Players.LocalPlayer is nil
			end;

			if player and player.Character and (getgenv().Checks.Checks.Whitelisted == true) and table.find(getgenv().Whitelisted.Whitelisted, player.Name) then
				-- Handle the case where getgenv().Whitelisted.Whitelisted or player.Name is nil
			end;

			if player and player.Character and (getgenv().Checks.Checks.Friends == true) and player:IsFriendsWith(Players.LocalPlayer.UserId) then 
				-- Handle the case where Players.LocalPlayer is nil
			end;

			if player and player.Character and (getgenv().Checks.Checks.Dead == true) and (player.Character:FindFirstChild('BodyEffects') and player.Character:FindFirstChild('BodyEffects'):FindFirstChild('K.O') and player.Character:FindFirstChild('BodyEffects'):FindFirstChild('K.O').Value == true or false) then 
				-- Handle the case where any of the FindFirstChild calls return nil
			end;

			if player and player.Character and (getgenv().Checks.Checks.Wallcheck == true) and BehindWall(player.Character) == true then 
				-- Handle the case where BehindWall function returns nil
			end;

			if player and player.Character and (getgenv().Checks.Checks.Visible == true) and not IsOnScreen(player.Character) then 
				-- Handle the case where IsOnScreen function returns nil
			end;

			if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Anti == true) and (player.Character.PrimaryPart.Velocity.X >= 35 or player.Character.PrimaryPart.Velocity.Y >= 20 or player.Character.PrimaryPart.Velocity.Z >= 35 or player.Character.PrimaryPart.Velocity.X <= -30 or player.Character.PrimaryPart.Velocity.Y <= -25 or player.Character.PrimaryPart.Velocity.Z <= -30)  then
				-- Handle the case where any of the Velocity properties are nil
			end;

			if player and player.Character and (getgenv().Checks.Checks.LocalPlayer == true) and player == Players.LocalPlayer then 
				-- Handle the case where Players.LocalPlayer is nil
			end;

			if player and player.Character and (getgenv().Checks.Checks.Grabbed == true) and (player.Character ~= nil and player.Character:FindFirstChild('GRABBING_CONSTRAINT') or false) then 
				-- Handle the case where any of the FindFirstChild calls return nil
			end;

			-- Distance calculation
			if (player.Character) and (player.Character and player.Character.PrimaryPart or false) then 
				local part_pos = player.Character.PrimaryPart.Position;
				local on_screen_pos = workspace.CurrentCamera:WorldToViewportPoint(part_pos);

				local dis_on_screen = CompareDis(mouse_pos, Vector2.new(on_screen_pos.X, on_screen_pos.Y));

				if (getgenv().FOV.Main.Enabled
					== true) then 
					if IsOnScreen(player.Character) and 
						tonumber(getgenv().HushConfigSets.Main.SilentRadius) >= tonumber(dis_on_screen) and 
						tonumber(dis_on_screen) < tonumber(nearest_dis) then
						nearest_dis = dis_on_screen;
						nearest_plr = player;
					end;
				else
					if (dis_on_screen < nearest_dis) then 
						nearest_dis = dis_on_screen;
						nearest_plr = player;
					end;
				end;
			end;
		end;
		return nearest_plr;
	elseif tostring(t):lower() == 'lock' then
		local mouse_pos = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y);
		------------------------
		local nearest_plr = nil;
		local nearest_dis = math.huge;

		for i, player in ipairs(Players:GetPlayers()) do
			-- Checks
			if (getgenv().Checks.Checks.Character == true) and not (player.Character) then 
				--
			end;
			if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.PrimaryPart == true) and not (player.Character.PrimaryPart) then 
				--
			end;
			if player and player.Character and (getgenv().Checks.Checks.Teamcheck == true) and (player.Team == Players.LocalPlayer.Team) then 
				--
			end;
			if player and player.Character and (getgenv().Checks.Checks.Whitelisted == true) and table.find(getgenv().Whitelisted.Whitelisted, player.Name) then
				--
			end;
			if player and player.Character and (getgenv().Checks.Checks.Friends == true) and player:IsFriendsWith(Players.LocalPlayer.UserId) then 
				--
			end;
			if player and player.Character and (getgenv().Checks.Checks.Dead == true) and (player.Character:FindFirstChild('BodyEffects') and player.Character:FindFirstChild('BodyEffects'):FindFirstChild('K.O') and player.Character:FindFirstChild('BodyEffects'):FindFirstChild('K.O').Value == true or false) then 
				--
			end;
			if player and player.Character and (getgenv().Checks.Checks.Wallcheck == true) and BehindWall(player.Character) == true then 
				--
			end;
			if player and player.Character and (getgenv().Checks.Checks.Visible == true) and not IsOnScreen(player.Character) then 
				--
			end
			if player and player.Character and (getgenv().Checks.Checks.Anti == true) and (player.Character.PrimaryPart.Velocity.X >= 35 or player.Character.PrimaryPart.Velocity.Y >= 20 or player.Character.PrimaryPart.Velocity.Z >= 35 or player.Character.PrimaryPart.Velocity.X <= -30 or player.Character.PrimaryPart.Velocity.Y <= -25 or player.Character.PrimaryPart.Velocity.Z <= -30) then
				--
			end;
			if player and player.Character and (getgenv().Checks.Checks.LocalPlayer == true) and player == Players.LocalPlayer then 
				--
			end;
			if player and player.Character and (getgenv().Checks.Checks.Grabbed == true) and (player.Character and player.Character:FindFirstChild('GRABBING_CONSTRAINT') or false) then 
				--
			end;

			-- Distance calculation
			if (player.Character) and (player.Character and player.Character.PrimaryPart or false) then 
				local part_pos = player.Character.PrimaryPart.Position;
				local on_screen_pos = workspace.CurrentCamera:WorldToScreenPoint(part_pos);

				local dis_on_screen = CompareDis(mouse_pos, Vector2.new(on_screen_pos.X, on_screen_pos.Y));

				if (getgenv().UseLess.Aimbot.FOV.Enabled == true) then 
					if IsOnScreen(player.Character) and (getgenv().UseLess.Aimbot.FOV.Radius  >= dis_on_screen) and (dis_on_screen < nearest_dis) then
						nearest_dis = dis_on_screen;
						nearest_plr = player;
					end;
				else
					if (dis_on_screen < nearest_dis) then 
						nearest_dis = dis_on_screen;
						nearest_plr = player;
					end;
				end;
			end;
		end;
		return nearest_plr;
	elseif tostring(t):lower() == 'triggerbot' then
		local mouse_pos = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y);
		------------------------
		local nearest_plr = nil;
		local nearest_dis = math.huge;

		for i, player in ipairs(Players:GetPlayers()) do
			-- Checks
			if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Character == true) and not (player.Character) then 
				--
			end;
			if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.PrimaryPart == true) and not (player.Character.PrimaryPart) then 
				--
			end;
			if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Teamcheck == true) and (player.Team == Players.LocalPlayer.Team) then 
				--
			end;
			if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Whitelisted == true) and table.find(getgenv().Whitelisted.Whitelisted, player.Name) then
				--
			end;
			if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Friends == true) and player:IsFriendsWith(Players.LocalPlayer.UserId) then 
				--
			end;
			if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Dead == true) and (player.Character:FindFirstChild('BodyEffects') and player.Character:FindFirstChild('BodyEffects'):FindFirstChild('K.O') and player.Character:FindFirstChild('BodyEffects'):FindFirstChild('K.O').Value == true or false) then
				--
			end;
			if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Wallcheck == true) and BehindWall(player.Character) == true then 
				--
			end;
			if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Visible == true) and not IsOnScreen(player.Character) then 
				--
			end
			if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Anti == true) and (player.Character.PrimaryPart.Velocity.X >= 55 or player.Character.PrimaryPart.Velocity.Y >= 30 or player.Character.PrimaryPart.Velocity.Z >= 45 or player.Character.PrimaryPart.Velocity.X <= -40 or player.Character.PrimaryPart.Velocity.Y <= -30 or player.Character.PrimaryPart.Velocity.Z <= -30) then
				--
			end;
			if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.LocalPlayer == true) and player == Players.LocalPlayer then 
				--
			end;
			if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Grabbed == true) and (player.Character ~= nil and player.Character:FindFirstChild('GRABBING_CONSTRAINT') or false) then 
				--
			end;

			-- Distance calculation
			if (player.Character) and (player.Character and player.Character.PrimaryPart or false) then 
				local part_pos = player.Character.PrimaryPart.Position;
				local on_screen_pos = workspace.CurrentCamera:WorldToViewportPoint(part_pos);

				local dis_on_screen = CompareDis(mouse_pos, Vector2.new(on_screen_pos.X, on_screen_pos.Y));

				if (getgenv().TriggerBotConfig.Triggerbot.Prediction.Enabled == true) then 
					if IsOnScreen(player.Character) and (getgenv().TriggerBotConfig.Triggerbot.Prediction.Amount >= dis_on_screen) and (dis_on_screen < nearest_dis) then
						nearest_dis = dis_on_screen;
						nearest_plr = player;
					end;
				else
					if (dis_on_screen < nearest_dis) then 
						nearest_dis = dis_on_screen;
						nearest_plr = player;
					end;
				end;

			end;
		end;
		return nearest_plr;
	end;

end;

local Pred = Drawing.new("Text")
Pred.Text = "Prediction: "
Pred.Color = Color3.new(1, 1, 1)
Pred.Visible = true
Pred.Size = 16
Pred.Outline = true
Pred.Font = 3
Pred.Position = Vector2.new(20, 210)
Pred.ZIndex = 1500

local Resolver = Drawing.new("Text")
Resolver.Text = "Resolver: "
Resolver.Color = Color3.new(1, 1, 1)
Resolver.Visible = true
Resolver.Size = 16
Resolver.Outline = true
Resolver.Font = 3
Resolver.Position = Vector2.new(20, 225)
Resolver.ZIndex = 1500


local silenttarg = Drawing.new("Text")
silenttarg.Text = "Silent Aim Target: "
silenttarg.Color = Color3.new(1, 1, 1)
silenttarg.Visible = true
silenttarg.Size = 16
silenttarg.Outline = true
silenttarg.Font = 3
silenttarg.Position = Vector2.new(20, 255)
silenttarg.ZIndex = 1500


local camlocktarg = Drawing.new("Text")
camlocktarg.Text = "Target Aim Lock Target: "
camlocktarg.Color = Color3.new(1, 1, 1)
camlocktarg.Visible = true
camlocktarg.Size = 16
camlocktarg.Outline = true
camlocktarg.Font = 3
camlocktarg.Position = Vector2.new(20, 270)
camlocktarg.ZIndex = 1500


game:GetService("RunService").Heartbeat:Connect(function()
	if ShowText.Enabled == true then 
		Pred.Visible = true
		Pred.Text = "Prediction: "..tostring(getgenv().HushConfigSets.Main.SilentPrediction)
		Resolver.Visible = true
		Resolver.Text = "Resolver: "..tostring(getgenv().SilentConfigs.ResolverMethod)
		silenttarg.Visible = true
		silenttarg.Text = "Silent Aim Target: "..tostring(Hush_CONSTRUCTORS.Data.Silent_Target)
		camlocktarg.Visible = true
		camlocktarg.Text = "Target Aim Lock Target: "..tostring(Plr.Character.Humanoid.DisplayName)


	else
		Pred.Visible = false
		Resolver.Visible = false
		silenttarg.Visible = false
		camlocktarg.Visible = false
	end
end)

local GetNearestPlayerLock = function(t) -- new function cuz i needa fix smth 
	local mouse_pos = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y);
	------------------------
	local nearest_plr = nil;
	local nearest_dis = math.huge;

	for i, player in ipairs(Players:GetPlayers()) do
		-- Checks
		if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Character == true) and not (player.Character) then 
			--
		end;
		if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.PrimaryPart == true) and not (player.Character.PrimaryPart) then 
			--
		end;
		if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Teamcheck == true) and (player.Team == Players.LocalPlayer.Team) then 
			--
		end;
		if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Whitelisted == true) and table.find(getgenv().Whitelisted.Whitelisted, player.Name) then
			--
		end;
		if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Friends == true) and player:IsFriendsWith(Players.LocalPlayer.UserId) then 
			--
		end;
		if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Dead == true) and (player.Character:FindFirstChild('BodyEffects') and player.Character:FindFirstChild('BodyEffects'):FindFirstChild('K.O') and player.Character:FindFirstChild('BodyEffects'):FindFirstChild('K.O').Value == true or false) then 
			--
		end;
		if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Wallcheck == true) and BehindWall(player.Character) == true then 
			--
		end;
		if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Visible == true) and not IsOnScreen(player.Character) then 
			--
		end
		if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Anti == true) and (player.Character.PrimaryPart.Velocity.X >= 35 or player.Character.PrimaryPart.Velocity.Y >= 20 or player.Character.PrimaryPart.Velocity.Z >= 35 or player.Character.PrimaryPart.Velocity.X <= -30 or player.Character.PrimaryPart.Velocity.Y <= -25 or player.Character.PrimaryPart.Velocity.Z <= -30) then
			--
		end;
		if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.LocalPlayer == true) and player == Players.LocalPlayer then 
			--
		end;
		if player and player.Character and player.Character.PrimaryPart and (getgenv().Checks.Checks.Grabbed == true) and (player.Character ~= nil and player.Character:FindFirstChild('GRABBING_CONSTRAINT') or false) then 
			--
		end;

		-- Distance calculation
		if (player.Character) and (player.Character and player.Character.PrimaryPart) then 
			local part_pos = player.Character.PrimaryPart.Position;
			local on_screen_pos = workspace.CurrentCamera:WorldToViewportPoint(part_pos);

			local dis_on_screen = CompareDis(mouse_pos, Vector2.new(on_screen_pos.X, on_screen_pos.Y));

			if (getgenv().UseLess.Aimbot.FOV.Enabled == true) then 
				if IsOnScreen(player.Character) and (getgenv().UseLess.Aimbot.FOV.Radius >= dis_on_screen) and (dis_on_screen < nearest_dis) then
					nearest_dis = dis_on_screen;
					nearest_plr = player;
				end;
			else
				if (dis_on_screen < nearest_dis) then 
					nearest_dis = dis_on_screen;
					nearest_plr = player;
				end;
			end;
		end;
	end;
	return nearest_plr;
end;
-------------------------------------------

local IgnorePart = true

local IgnoredParts = {"RightFoot", "LeftFoot"}
-- Nearest Point --
local GetNearestPoint = function(char) 
	local mouse_pos = UserInputService:GetMouseLocation();
	------------------------
	local nearest_point = nil;
	local nearest_dis = math.huge;
	if IgnorePart == true then
		if char then 
			for i, part in ipairs(char:GetDescendants()) do 
				if (not table.find(IgnoredParts, char.Name)) then
					if part:IsA('BasePart') then 
						local on_screen_pos = workspace.CurrentCamera:WorldToViewportPoint(part.Position);
						local dis_on_screen = CompareDis(mouse_pos, Vector2.new(on_screen_pos.X, on_screen_pos.Y));
						if (dis_on_screen < nearest_dis) then
							nearest_dis = dis_on_screen;
							nearest_point = part;
						end;
					end;
				end;
			end;
		end;
	end;

	-------------------------------------------
	return nearest_point;
end;



-------------------------------------------
-- Lock --
local LockPredGen = function(char)
	local Resolver = false;
	if char then
		local Data = {
			Positions = {
				Last = nil;
				Current = nil;
			};
			Time      = {
				Last = nil;
				Current = nil;
			};
		};
		----------------------------------------
		coroutine.wrap(function()
			if (Hush_CONSTRUCTORS.Data.Lock_Target) and (char ~= nil and Hush_CONSTRUCTORS.Data.Lock_Target.Character) then 
				pcall(function()
					Data.Positions.Last = char.PrimaryPart.Position;
					Data.Time.Last = tick();
					---------------------------------------
					wait(0.00350);
					---------------------------------------
					Data.Positions.Current = char.PrimaryPart.Position;
					Data.Time.Current = tick();
				end);
			end;
		end)();

		-- Selected Part --
		local SelectedPart = (
			getgenv().UseLess.Aimbot.Hitting == 0 and GetNearestPoint(char) or
				getgenv().UseLess.Aimbot.Hitting == 1 and char.PrimaryPart or
				getgenv().UseLess.Aimbot.Hitting == 2 and char[getgenv().UseLess.Aimbot.BasePart] or
				getgenv().UseLess.Aimbot.Hitting == 3 and char:children()[math.random(1, #char:children())] or
				char.PrimaryPart
		) or char.PrimaryPart or char.HumanoidRootPart;
		-- Resolver --
		if (getgenv().UseLess.Aimbot.AutomaticResolver == true) then 
			if (SelectedPart.Velocity.X >= 35 or SelectedPart.Velocity.X <= -30 or SelectedPart.Velocity.Y >= 50 or SelectedPart.Velocity.Y <= -25 or SelectedPart.Velocity.Z >= 40 or SelectedPart.Velocity.Z <= -30) then 
				Resolver = true;
			end;
		end;
		if (Resolver == true) then
			SelectedPart.Velocity = Vector3.new(
				-- X Axis
				0 + (
					-- V1
					tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'MoveDirection' and ((char.Humanoid.MoveDirection * char.Humanoid.WalkSpeed) * getgenv().UseLess.Aimbot.Resolver.AutomaticPred == true and math.random(1.25, 2) or getgenv().UseLess.Aimbot.Resolver.MoveDirection).X
						or
						-- V2
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'LookVector' and ((char.PrimaryPart.CFrame.LookVector * char.Humanoid.WalkSpeed) * (getgenv().UseLess.Aimbot.Resolver.AutomaticPred == true and math.random(1.15, 2)) or getgenv().UseLess.Aimbot.Resolver.LookVector).X
						or
						-- V3
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'SkidStyle' and 0
						or
						-- V4
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().UseLess.Aimbot.Resolver.Delta / 100) ).X
						or
						-- V ?
						0

				),
				-- Y Axis
				0 + (
					-- V1
					tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'MoveDirection' and ((char.Humanoid.MoveDirection * char.Humanoid.WalkSpeed) * getgenv().UseLess.Aimbot.Resolver.AutomaticPred == true and math.random(1.25, 2) or getgenv().UseLess.Aimbot.Resolver.MoveDirection).Y
						or
						-- V2
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'LookVector' and ((char.PrimaryPart.CFrame.LookVector * char.Humanoid.WalkSpeed) * (getgenv().UseLess.Aimbot.Resolver.AutomaticPred == true and math.random(1.15, 2)) or getgenv().UseLess.Aimbot.Resolver.LookVector).Y
						or
						-- V3
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'SkidStyle' and 0
						or
						-- V4
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().UseLess.Aimbot.Resolver.Delta / 100) ).Y
						or
						-- V ?
						0

				),
				-- Z Axis
				0 + (
					-- V1
					tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'MoveDirection' and ((char.Humanoid.MoveDirection * char.Humanoid.WalkSpeed) * getgenv().UseLess.Aimbot.Resolver.AutomaticPred == true and math.random(1.25, 2) or getgenv().UseLess.Aimbot.Resolver.MoveDirection).Z
						or
						-- V2
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'LookVector' and ((char.PrimaryPart.CFrame.LookVector * char.Humanoid.WalkSpeed) * (getgenv().UseLess.Aimbot.Resolver.AutomaticPred == true and math.random(1.15, 2)) or getgenv().UseLess.Aimbot.Resolver.LookVector).Z
						or
						-- V3
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'SkidStyle' and 0
						or
						-- V4
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().UseLess.Aimbot.Resolver.Delta / 100) ).Z
						or
						-- V ?
						0

				)
			);
			SelectedPart.AssemblyLinearVelocity = Vector3.new(
				-- X Axis
				0 + (
					-- V1
					tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'MoveDirection' and ((char.Humanoid.MoveDirection * char.Humanoid.WalkSpeed) * getgenv().UseLess.Aimbot.Resolver.AutomaticPred == true and math.random(1.25, 2) or getgenv().UseLess.Aimbot.Resolver.MoveDirection).X
						or
						-- V2
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'LookVector' and ((char.PrimaryPart.CFrame.LookVector * char.Humanoid.WalkSpeed) * (getgenv().UseLess.Aimbot.Resolver.AutomaticPred == true and math.random(1.15, 2)) or getgenv().UseLess.Aimbot.Resolver.LookVector).X
						or
						-- V3
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'SkidStyle' and 0
						or
						-- V4
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().UseLess.Aimbot.Resolver.Delta / 100) ).X
						or
						-- V ?
						0

				),
				-- Y Axis
				0 + (
					-- V1
					tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'MoveDirection' and ((char.Humanoid.MoveDirection * char.Humanoid.WalkSpeed) * getgenv().UseLess.Aimbot.Resolver.AutomaticPred == true and math.random(1.25, 2) or getgenv().UseLess.Aimbot.Resolver.MoveDirection).Y
						or
						-- V2
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'LookVector' and ((char.PrimaryPart.CFrame.LookVector * char.Humanoid.WalkSpeed) * (getgenv().UseLess.Aimbot.Resolver.AutomaticPred == true and math.random(1.15, 2)) or getgenv().UseLess.Aimbot.Resolver.LookVector).Y
						or
						-- V3
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'SkidStyle' and 0
						or
						-- V4
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().UseLess.Aimbot.Resolver.Delta / 100) ).Y
						or
						-- V ?
						0

				),
				-- Z Axis
				0 + (
					-- V1
					tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'MoveDirection' and ((char.Humanoid.MoveDirection * char.Humanoid.WalkSpeed) * getgenv().UseLess.Aimbot.Resolver.AutomaticPred == true and math.random(1.25, 2) or getgenv().UseLess.Aimbot.Resolver.MoveDirection).Z
						or
						-- V2
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'LookVector' and ((char.PrimaryPart.CFrame.LookVector * char.Humanoid.WalkSpeed) * (getgenv().UseLess.Aimbot.Resolver.AutomaticPred == true and math.random(1.15, 2)) or getgenv().UseLess.Aimbot.Resolver.LookVector).Z
						or
						-- V3
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'SkidStyle' and 0
						or
						-- V4
						tostring(getgenv().UseLess.Aimbot.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().UseLess.Aimbot.Resolver.Delta / 100) ).Z
						or
						-- V ?
						0

				)
			);
		end;
		----------------------------------------------
		-- Actual Prediction --
		if (getgenv().UseLess.Aimbot.Prediction.Enabled == true) then
			Predicted_Pos = SelectedPart.Position + (SelectedPart.Velocity * getgenv().UseLess.Aimbot.Prediction.Amount) + (Vector3.new(
			-- X
			getgenv().UseLess.Aimbot.Shake.Enabled == true and math.random(getgenv().UseLess.Aimbot.Shake.X.Random[1], getgenv().UseLess.Aimbot.Shake.X.Random[2]) or 0,
			-- Y
			getgenv().UseLess.Aimbot.Shake.Enabled == true and math.random(getgenv().UseLess.Aimbot.Shake.Y.Random[1], getgenv().UseLess.Aimbot.Shake.Y.Random[2]) or 0,
			-- Z
			getgenv().UseLess.Aimbot.Shake.Enabled == true and math.random(getgenv().UseLess.Aimbot.Shake.Z.Random[1], getgenv().UseLess.Aimbot.Shake.Z.Random[2]) or 0
			) / 10);
		else
			Predicted_Pos = SelectedPart.Position + (SelectedPart.Velocity) + (Vector3.new(
			-- X
			getgenv().UseLess.Aimbot.Shake.Enabled == true and math.random(getgenv().UseLess.Aimbot.Shake.X.Random[1], getgenv().UseLess.Aimbot.Shake.X.Random[2]) or 0,
			-- Y
			getgenv().UseLess.Aimbot.Shake.Enabled == true and math.random(getgenv().UseLess.Aimbot.Shake.Y.Random[1], getgenv().UseLess.Aimbot.Shake.Y.Random[2]) or 0,
			-- Z
			getgenv().UseLess.Aimbot.Shake.Enabled == true and math.random(getgenv().UseLess.Aimbot.Shake.Z.Random[1], getgenv().UseLess.Aimbot.Shake.Z.Random[2]) or 0
			) / 10);
		end;

		if (getgenv().UseLess.Aimbot.Smoothness.Enabled == true) then 
			workspace.CurrentCamera:Interpolate(CFrame.new(workspace.CurrentCamera.CFrame.Position, Predicted_Pos), CFrame.new(), getgenv().UseLess.Aimbot.Smoothness.Amount, Enum.EasingStyle[getgenv().UseLess.Aimbot.Smoothness.EasingStyle], Enum.EasingDirection[getgenv().UseLess.Aimbot.Smoothness.EasingDirection]);
		else
			return CFrame.new(Camera.CFrame.Position, Predicted_Pos);
		end;
	end;
end;
table.insert(Hush_CONSTRUCTORS.Connections.Misc, RunService.RenderStepped:Connect((function()
	if (Hush_CONSTRUCTORS.Booleans.Lock == true) then 
		if not (Hush_CONSTRUCTORS.Data.Lock_Target) then 
			Hush_CONSTRUCTORS.Data.Lock_Target = GetNearestPlayerLock();
		elseif (Hush_CONSTRUCTORS.Data.Lock_Target) then
			if (getgenv().Hush) and (Hush_CONSTRUCTORS) and (Hush_CONSTRUCTORS.Data.Lock_Target and Hush_CONSTRUCTORS.Data.Lock_Target.Character) then
				local Predicted_Pos = LockPredGen(Hush_CONSTRUCTORS.Data.Lock_Target.Character);
				if (Predicted_Pos) then 
					workspace.CurrentCamera.CFrame = Predicted_Pos;
					if (getgenv().UseLess.Aimbot.RotateChar == true) then 
						Players.LocalPlayer.Character.PrimaryPart.CFrame = CFrame.lookAt(Players.LocalPlayer.Character.PrimaryPart.Position, Predicted_Pos); -- Since its a vector3
					end;
				end;
			end;
		end;
	end;
end)));
-------------------------------------------
-- Keybind handling --
-------------------------------------------
table.insert(Hush_CONSTRUCTORS.Connections.Keybinds, UserInputService.InputBegan:Connect(function(Key, gameProcessed) 
	if not (gameProcessed) and (Key.KeyCode == Enum.KeyCode[getgenv().Keys.Keybinds.CamSpin]) and (getgenv().SpinningTable.Spinning.Cam.Enabled == true) then 
		local data = {
			start = tick();
		};
		Hush_CONSTRUCTORS.Coroutines['360 Cam'] = coroutine.wrap(function()
			while (true) and (getgenv().Hush) do 
				local eta = tick() - data.start;
				workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position) * CFrame.Angles(0, math.rad(eta * getgenv().SpinningTable.Spinning.Cam.Degrees * getgenv().SpinningTable.Spinning.Cam.Speed), 0) * CFrame.new(0, 0, -5);
				if (eta >= 1 / getgenv().SpinningTable.Spinning.Cam.Speed) then break end; -- Formula
				task.wait();
			end;
		end) -- Put it in a coroutine so it doesn't stop further execution of the code (because the fov is gonna be added later cuz im a lazy fuck XD)
		Hush_CONSTRUCTORS.Coroutines['360 Cam']();
	elseif not (gameProcessed) and (Key.KeyCode == Enum.KeyCode[getgenv().Keys.Keybinds.CharSpin]) and (getgenv().SpinningTable.Spinning.Char.Enabled == true) then
		local data = {
			start = tick();
			cframe = Players.LocalPlayer.Character.PrimaryPart.CFrame;
			angle = math.rad(getgenv().SpinningTable.Spinning.Char.Degrees);
		};
		Hush_CONSTRUCTORS.Coroutines['360 Char'] = coroutine.wrap(function()
			while (true) and (getgenv().Hush) do 
				local eta = tick() - data.start;
				local angle = math.rad(eta * 360 * getgenv().SpinningTable.Spinning.Char.Speed);
				if (angle >= data.angle) then 
					angle = data.angle;
				end
				Players.LocalPlayer.Character:SetPrimaryPartCFrame(data.cframe * CFrame.Angles(0, angle, 0));
				if (angle >= data.angle) then 
					break;
				end;
				task.wait();
			end
		end) -- Put it in a coroutine so it doesn't stop further execution of the code (because the fov is gonna be added later cuz im a lazy fuck XD)
		Hush_CONSTRUCTORS.Coroutines['360 Char']();
	elseif not (gameProcessed) and (Key.KeyCode == Enum.KeyCode[getgenv().Keys.Keybinds.Panic]) and (getgenv().Enables.Panic == true) then
		Hush_CONSTRUCTORS:Panic();
	elseif not (gameProcessed) and (Key.KeyCode == Enum.KeyCode[getgenv().Keys.Keybinds.Triggerbot]) and (getgenv().Enables.TBot == true) then
		Hush_CONSTRUCTORS.Booleans.Triggerbot = not Hush_CONSTRUCTORS.Booleans.Triggerbot;
	elseif not (gameProcessed) and (Key.KeyCode == Enum.KeyCode[getgenv().Keys.Keybinds.LagSpike]) and (getgenv().LagSpikeConfig.LagSpike.Enabled == true) then
		settings():GetService('NetworkSettings').IncomingReplicationLag = getgenv().LagSpikeConfig.LagSpike.Amount;
		coroutine.wrap(function()
			ReplicatedStorage:FindFirstChild('DefaultSoundEvents'):FindFirstChild('AddCharacterLoadedEvent'):FireServer();
		end)();
		task.wait(getgenv().LagSpikeConfig.LagSpike.Duration);
		settings():GetService('NetworkSettings').IncomingReplicationLag = 0;
	elseif not (gameProcessed) and (Key.KeyCode == Enum.KeyCode[getgenv().Keys.Keybinds.BadTalk]) and (getgenv().ShitTalkingConfig.ShitTalk.Enabled == true) then
		-- Bad / Sh*t talk --
		ReplicatedStorage:FindFirstChild('DefaultChatSystemChatEvents'):FindFirstChild('SayMessageRequest'):FireServer(
		getgenv().ShitTalkingConfig.ShitTalk.Phrases[math.random(1, #getgenv().ShitTalkingConfig.ShitTalk.Phrases)],
		'All'
		);
	elseif not (gameProcessed) and (Key.KeyCode == Enum.KeyCode[getgenv().Keys.Keybinds.AutoSortInv]) and (getgenv().InvSets.InventorySorter.Enabled == true) then
		coroutine.wrap(function()
			if not rawget(game.CoreGui:GetChildren(), 'HushGuns') then
				CACHE = Instance.new('Folder', game.CoreGui);
				CACHE.Name = 'HushGuns'
			else
				CACHE = game.CoreGui.HushGuns;
			end;
			local Backpack = Players.LocalPlayer.Backpack;

			-- Tool Names --
			-- will be adding more soon cuz i dont play da hood fuck that
			local Names = {
				DB = {
					'Double Barrel';
					'[Double-Barrel SG]';
					'[DB]';
					'DB';
					'[Double Barrel]';
					'[Double-Barrel]';
				};
				Rev = {
					'[Revolver]';
					'Rev';
					'Revolver';
					'[Rev]';
				};
				Phone = {
					'Phone';
					'[Phone]';
				};
				Wallet = {
					'Wallet';
					'[Wallet]';
				};
				Katana = {
					'Katana';
					'[Katana]';
				};
				TSG = {
					'[TacticalShotgun]';
					'TacticalShotgun';
					'[TSG]';
					'[TG]';
					'[Tactical-Shotgun]';
					'[Tactical Shotgun]';
				};
				SG = {
					'Shotgun';
					'[SG]';
					'[Shotgun]';
					'SG';
				};
				Silencer = {
					'Silencer';
					'[Silencer]';
				};
				Bat = {
					'Bat';
					'[Bat]';
				};
				Molotov = {
					'Molotov';
					'[Molotov]';
				};
				Flamethrower = {
					'Flamethrower';
					'[Flamethrower]';
				};
				Taser = {
					'Taser';
					'[Taser]';
				};
				-- Food --
				Pizza = {
					'Pizza';
					'[Pizza]';
				};
				Chicken = {
					'Chicken';
					'[Chicken]';
				};
				Cranberry = {
					'Cranberry';
					'[Cranberry]';
				};
				Lettuce = {
					'Lettuce';
					'[Lettuce]';
				};
				Popcorn = {
					'Popcorn';
					'[Popcorn]';
				};
				HotDog = {
					'HotDog';
					'Hotdog';
					'[HotDog]';
					'[Hotdog]';
				};
				-- Misc ig?? --
				Flower = {
					'Flower';
					'[Flower]';
				}; -- legit adding useless ass shit but for the quality.
				PepperSpray = {
					'PepperSpray';
					'[PepperSpray]';
				};
				Cuffs = {
					'Cuffs';
					'[Cuffs]';
				};
			};
			-- Accepted aliases
			local DB_Aliases = {
				'DB';
				'DoubleBarrel';
				'Double-Barrel';
			}; -- Double Barrel Shotgun aliases
			local Rev_Aliases = {
				'Rev';
				'Revolver';
			}; -- Revolver aliases
			local Phone_Aliases = {
				'Phone';
			}; -- Phone aliases
			local Wallet_Aliases = {
				'Wallet';
			}; -- Wallet aliases
			local Katana_Aliases = {
				'Katana';
			}; -- Katana aliases
			local TSG_Aliases = {
				'TacticalShotgun';
				'TSG';
				'Tactical-Shotgun';
				'Tactical Shotgun';
			}; -- Tactical shotgun aliases
			local Shotgun_Aliases = {
				'Shotgun';
				'SG';
				'ShotG';
				'Shotg';
			};
			local Flower_Aliases = {
				'Flower';
				'[Flower]';
			};
			local Silencer_Aliases = {
				'Silencer';
			};
			local Bat_Aliases = {
				'Bat';
			};
			local Molotov_Aliases = {
				'Molotov';
			};
			local Flamethrower_Aliases = {
				'Flamethrower';
				'Flamesplitter';
				'FT';
			};
			local Taser_Aliases = {
				'Taser';
			};
			local PepperSpray_Aliases = {
				'PepperSpray';
				'PS';
				'pepperspray';
			};
			local Cuffs_Aliases = {
				'Cuffs';
				'[Cuffs]';
			};
			local Pizza_Aliases = {
				'Pizza';
				'[Pizza]';
			};
			local Chicken_Aliases = {
				'Chicken';
				'[Chicken]';
				'Turkey';
			};
			local Cranberry_Aliases = {
				'Cranberry';
				'[Cranberry]';
			};
			local Lettuce_Aliases = {
				'Lettuce';
				'[Lettuce]';
				'Salad';
			};
			local Popcorn_Aliases = {
				'Popcorn';
				'PC';
				'pc';
				'[Popcorn]';
			};
			local HotDog_Aliases = {
				'Hotdog';
				'[HotDog]';
				'[Hotdog]';
				'HotDog';
			};
			-------------------------------------
			-- Data
			local Data = {};
			-------------------------------------
			for index, tool in ipairs(Backpack:GetChildren()) do
				tool.Parent = CACHE;
			end;
			for order, gun in ipairs(getgenv().InvSets.InventorySorter.List) do
				-- DB
				if table.find(DB_Aliases, gun) then 
					-- Double Barrel Shotgun
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.DB, tool.Name) then 
							Data.DB = tool;
						end;
					end;
					if (Data.DB) then 
						Data.DB.Parent = Backpack;
					end;
				elseif table.find(Rev_Aliases, gun) then
					-- REV
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.Rev, tool.Name) then 
							Data.Rev = tool;
						end;
					end;
					if (Data.Rev) then 
						Data.Rev.Parent = Backpack;
					end;
				elseif table.find(Phone_Aliases, gun) then
					-- PHONE
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.Phone, tool.Name) then 
							Data.Phone = tool;
						end;
					end;
					if (Data.Phone) then 
						Data.Phone.Parent = Backpack;
					end;
				elseif table.find(Wallet_Aliases, gun) then
					-- WALLET
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.Wallet, tool.Name) then 
							Data.Wallet = tool;
						end;
					end;
					if (Data.Wallet) then 
						Data.Wallet.Parent = Backpack;
					end;
				elseif table.find(Katana_Aliases, gun) then
					-- KATANA
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.Katana, tool.Name) then 
							Data.Katana = tool;
						end;
					end;
					if (Data.Katana) then 
						Data.Katana.Parent = Backpack;
					end;
				elseif table.find(TSG_Aliases, gun) then
					-- TACTICAL SHOTGUN
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.TSG, tool.Name) then 
							Data.TSG = tool;
						end;
					end;
					if (Data.TSG) then 
						Data.TSG.Parent = Backpack;
					end;
				elseif table.find(Shotgun_Aliases, gun) then
					-- SHOTGUN
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.SG, tool.Name) then 
							Data.SG = tool;
						end;
					end;
					if (Data.SG) then 
						Data.SG.Parent = Backpack;
					end;
				elseif table.find(Flower_Aliases, gun) then
					-- FLOWER
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.Flower, tool.Name) then 
							Data.Flower = tool;
						end;
					end;
					if (Data.Flower) then 
						Data.Flower.Parent = Backpack;
					end;
				elseif table.find(Silencer_Aliases, gun) then
					-- SILENCER
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.Silencer, tool.Name) then 
							Data.Silencer = tool;
						end;
					end;
					if (Data.Silencer) then 
						Data.Silencer.Parent = Backpack;
					end;
				elseif table.find(Bat_Aliases, gun) then
					-- BAT
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.Bat, tool.Name) then 
							Data.Bat = tool;
						end;
					end;
					if (Data.Bat) then 
						Data.Bat.Parent = Backpack;
					end;
				elseif table.find(Molotov_Aliases, gun) then
					-- MOLOTOV
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.Molotov, tool.Name) then 
							Data.Molotov = tool;
						end;
					end;
					if (Data.Molotov) then 
						Data.Molotov.Parent = Backpack;
					end;
				elseif table.find(Flamethrower_Aliases, gun) then
					-- FLAMETHROWER
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.Flamethrower, tool.Name) then 
							Data.Flamethrower = tool;
						end;
					end;
					if (Data.Flamethrower) then 
						Data.Flamethrower.Parent = Backpack;
					end;
				elseif table.find(Taser_Aliases, gun) then
					-- TASER
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.Taser, tool.Name) then 
							Data.Taser = tool;
						end;
					end;
					if (Data.Taser) then 
						Data.Taser.Parent = Backpack;
					end;
				elseif table.find(PepperSpray_Aliases, gun) then
					-- PEPPER SPRAY
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.PepperSpray, tool.Name) then 
							Data.PepperSpray = tool;
						end;
					end;
					if (Data.PepperSpray) then 
						Data.PepperSpray.Parent = Backpack;
					end;
				elseif table.find(Cuffs_Aliases, gun) then
					-- CUFFS
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.Cuffs, tool.Name) then 
							Data.Cuffs = tool;
						end;
					end;
					if (Data.Cuffs) then 
						Data.Cuffs.Parent = Backpack;
					end;
				elseif table.find(Pizza_Aliases, gun) then
					-- PIZZA
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.Pizza, tool.Name) then 
							Data.Pizza = tool;
						end;
					end;
					if (Data.Pizza) then 
						Data.Pizza.Parent = Backpack;
					end;
				elseif table.find(Chicken_Aliases, gun) then
					-- CHICKEN
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.Chicken, tool.Name) then 
							Data.Chicken = tool;
						end;
					end;
					if (Data.Chicken) then 
						Data.Chicken.Parent = Backpack;
					end;
				elseif table.find(Lettuce_Aliases, gun) then
					-- LETTUCE
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.Lettuce, tool.Name) then 
							Data.Lettuce = tool;
						end;
					end;
					if (Data.Lettuce) then 
						Data.Lettuce.Parent = Backpack;
					end;
				elseif table.find(Popcorn_Aliases, gun) then
					-- POPCORN
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.Popcorn, tool.Name) then 
							Data.Popcorn = tool;
						end;
					end;
					if (Data.Popcorn) then 
						Data.Popcorn.Parent = Backpack;
					end;
				elseif table.find(HotDog_Aliases, gun) then
					-- HOT DOG
					for idx, tool in ipairs(CACHE:GetChildren()) do 
						if table.find(Names.HotDog, tool.Name) then 
							Data.HotDog = tool;
						end;
					end;
					if (Data.HotDog) then 
						Data.HotDog.Parent = Backpack;
					end;
				end;
			end;
			--------------------------------
			for idx, tool in ipairs(CACHE:GetChildren()) do
				tool.Parent = Backpack;
			end;
		end)();
		-------------------------------------------
	elseif not (gameProcessed) and (Key.KeyCode == Enum.KeyCode[getgenv().Keys.Keybinds.Macro]) and (getgenv().MacroConfig.Macro.Enabled == true) then
		Hush_CONSTRUCTORS.Booleans.Macro = not Hush_CONSTRUCTORS.Booleans.Macro;
		if (Hush_CONSTRUCTORS.Booleans.Macro == true) then 
			Hush_CONSTRUCTORS.Coroutines['Macro'] = coroutine.wrap(function()
				if tostring(getgenv().MacroConfig.Macro.Mode):lower() == 'legit' then 
					if tostring(getgenv().MacroConfig.Macro.Method):lower() == 'keypress' then 
						repeat
							RunService.RenderStepped:Wait();
							keypress(0x49);
							RunService.RenderStepped:Wait();
							keyrelease(0x49);
							RunService.RenderStepped:Wait();
							keypress(0x4F);
							RunService.RenderStepped:Wait();
							keyrelease(0x4F);
							RunService.RenderStepped:Wait();
						until Hush_CONSTRUCTORS.Booleans.Macro == false;
					elseif tostring(getgenv().MacroConfig.Macro.Method):lower() == 'virtual' then
						repeat
							RunService.RenderStepped:Wait();
							VirtualInputManager:SendKeyEvent(true, 'I', false, game);
							RunService.RenderStepped:Wait();
							VirtualInputManager:SendKeyEvent(true, 'O', false, game);
							RunService.RenderStepped:Wait();
							VirtualInputManager:SendKeyEvent(true, 'I', false, game);
							RunService.RenderStepped:Wait();
							VirtualInputManager:SendKeyEvent(true, 'O', false, game);
							RunService.RenderStepped:Wait();
						until Hush_CONSTRUCTORS.Booleans.Macro == false;
					end;
				elseif tostring(getgenv().MacroConfig.Macro.Mode):lower() == 'blatant' then
					if tostring(getgenv().MacroConfig.Macro.Method):lower() == 'keypress' then 
						RunService.RenderStepped:Wait();
						keypress(0x49);
						RunService.RenderStepped:Wait();
						keyrelease(0x49);
						RunService.RenderStepped:Wait();
						keypress(0x4F);
						RunService.RenderStepped:Wait();
						keyrelease(0x4F);
					elseif tostring(getgenv().MacroConfig.Macro.Method):lower() == 'virtual' then
						RunService.RenderStepped:Wait();
						VirtualInputManager:SendKeyEvent(true, 'I', false, game);
						RunService.RenderStepped:Wait();
						VirtualInputManager:SendKeyEvent(true, 'O', false, game);
						RunService.RenderStepped:Wait();
					end;
				end;
			end);
			Hush_CONSTRUCTORS.Coroutines['Macro']();
		end;
	elseif not (gameProcessed) and (Key.KeyCode == Enum.KeyCode[getgenv().Keys.Keybinds.SilentStrafe]) and (getgenv().StrafeConfig.Strafe.Enabled == true) then
		Hush_CONSTRUCTORS.Booleans.Strafe = not Hush_CONSTRUCTORS.Booleans.Strafe;
	end
end));
-------------------------------------------
-------------------------------------------
-- Memory Spoofer --
-------------------------------------------
Hush_CONSTRUCTORS.Coroutines['MemSpoofer'] = coroutine.wrap(function()
	while (true) and (getgenv().Hush) do
		if (getgenv().Hush) and (getgenv().MemorySpooferSettings.MemSpoofer.Enabled == true) then 
			Hush_CONSTRUCTORS.Coroutines['MemSpoofing'] = coroutine.wrap(function()
				local PerformanceStats = CoreGui:WaitForChild('RobloxGui'):WaitForChild('PerformanceStats', 1);
				local DevConsole = CoreGui:WaitForChild('DevConsoleMaster', 1);
				if (PerformanceStats ~= nil) then
					-- Method 1
					if (getgenv().MemorySpooferSettings.MemSpoofer.Method == 1) then 
						coroutine.wrap(function()
							for index, key in next, PerformanceStats:GetDescendants() do 
								if key:IsA('TextLabel') and key.Text == 'Mem' then 
									Hush_CONSTRUCTORS.Memory = Hush_CONSTRUCTORS.Memory + tonumber(string.format('%.2f', math.random() + math.random(-1, 1)))
									if (Hush_CONSTRUCTORS.Memory < math.random(getgenv().MemorySpooferSettings.MemSpoofer.Range[1], getgenv().MemorySpooferSettings.MemSpoofer.Range[2])) then 
										Hush_CONSTRUCTORS.Memory = Hush_CONSTRUCTORS.Memory + math.random() + math.random(1, 2)
									elseif (Hush_CONSTRUCTORS.Memory > math.random(getgenv().MemorySpooferSettings.MemSpoofer.Range[1] - math.random(10, 40), getgenv().MemorySpooferSettings.MemSpoofer.Range[2] - math.random(10, 30))) then
										Hush_CONSTRUCTORS.Memory = Hush_CONSTRUCTORS.Memory - (math.random() + math.random(1, 2))
									end
									key.Parent.ValueLabel.Text = string.format('%.2f MB', Hush_CONSTRUCTORS.Memory);
								end
							end
							if PerformanceStats:FindFirstChild('PS_Viewer') then 
								for index, key in next, PerformanceStats:FindFirstChild('PS_Viewer'):GetDescendants() do 
									if key:IsA('TextLabel') and string.find(key.Text, 'Current') then 
										key.Text = string.format('Current: %.2f MB', Hush_CONSTRUCTORS.Memory)
									end;
									if key:IsA('TextLabel') and string.find(key.Text, 'Average') then 
										key.Text = string.format('Average: %.2f MB', Hush_CONSTRUCTORS.Memory - (math.random() * 1.45));
									end;
								end
							end;
						end)();
						-- Method 0
					elseif (getgenv().MemorySpooferSettings.MemSpoofer.Method == 0) then
						coroutine.wrap(function()
							for index, key in next, PerformanceStats:GetDescendants() do 
								if key:IsA('TextLabel') and key.Text == 'Mem' then
									if not Hush_CONSTRUCTORS.Connections.CACHE_MEMORY['Spoofer1'] then
										-- Spoofer 1 is for the profile info
										-- Spoofer 2 is for the dev console
										Hush_CONSTRUCTORS.Connections.CACHE_MEMORY.Spoofer1 = key.Parent.ValueLabel:GetPropertyChangedSignal('Text'):Connect(function()
											if (getgenv().MemorySpooferSettings.MemSpoofer.Enabled == true) then 
												coroutine.wrap(function()
													Hush_CONSTRUCTORS.Memory = Hush_CONSTRUCTORS.Memory + tonumber(string.format('%.2f', math.random() + math.random(-1, 1)))
													if (Hush_CONSTRUCTORS.Memory < math.random(getgenv().MemorySpooferSettings.MemSpoofer.Range[1], getgenv().MemorySpooferSettings.MemSpoofer.Range[2])) then 
														Hush_CONSTRUCTORS.Memory = Hush_CONSTRUCTORS.Memory + math.random() + math.random(1, 2)
													elseif (Hush_CONSTRUCTORS.Memory > math.random(getgenv().MemorySpooferSettings.MemSpoofer.Range[1] - math.random(10, 40), getgenv().MemorySpooferSettings.MemSpoofer.Range[2] - math.random(10, 30))) then
														Hush_CONSTRUCTORS.Memory = Hush_CONSTRUCTORS.Memory - (math.random() + math.random(1, 2))
													end
													key.Parent.ValueLabel.Text = string.format('%.2f MB', Hush_CONSTRUCTORS.Memory);
													task.wait(getgenv().MemorySpooferSettings.MemSpoofer.Delay);
												end)();
											end;
										end);
									end;
								end
							end;
							if PerformanceStats:FindFirstChild('PS_Viewer') then 
								for index, key in next, PerformanceStats:FindFirstChild('PS_Viewer'):GetDescendants() do 
									if key:IsA('TextLabel') and string.find(key.Text, 'Current') then
										-- string.format('Current: %.2f MB', Hush_CONSTRUCTORS.Memory)
										if not Hush_CONSTRUCTORS.Connections.CACHE_MEMORY['Current'] then 
											Hush_CONSTRUCTORS.Connections.CACHE_MEMORY.Current = key:GetPropertyChangedSignal('Text'):Connect(function()
												key.Text = string.format('Current: %.2f MB', Hush_CONSTRUCTORS.Memory);
												task.wait(getgenv().MemorySpooferSettings.MemSpoofer.Delay);
											end);
										end;
									end;
									if key:IsA('TextLabel') and string.find(key.Text, 'Average') then 
										if not Hush_CONSTRUCTORS.Connections.CACHE_MEMORY['Avg'] then 
											Hush_CONSTRUCTORS.Connections.CACHE_MEMORY.Avg = key:GetPropertyChangedSignal('Text'):Connect(function()
												key.Text = string.format('Average: %.2f MB', Hush_CONSTRUCTORS.Memory + math.random());
												task.wait(getgenv().MemorySpooferSettings.MemSpoofer.Delay);
											end);
										end;
									end;
								end
							end;
						end)();
					end;

				end;
				if (DevConsole ~= nil) then
					if (getgenv().MemorySpooferSettings.MemSpoofer.Method == 1) then 
						coroutine.wrap(function()
							for index, key in next, DevConsole:GetDescendants() do 
								if key:IsA('TextButton') and key.Name == 'MemoryUsage_MB' then
									key.Text = string.format('%d MB', math.floor(tonumber(Hush_CONSTRUCTORS.Memory)));
								end;
							end
						end)();
					elseif (getgenv().MemorySpooferSettings.MemSpoofer.Method == 0) then
						coroutine.wrap(function()
							for index, key in next, DevConsole:GetDescendants() do 
								if key:IsA('TextButton') and key.Name == 'MemoryUsage_MB' then
									if not Hush_CONSTRUCTORS.Connections.CACHE_MEMORY.DevConsole then 
										Hush_CONSTRUCTORS.Connections.CACHE_MEMORY.DevConsole = key:GetPropertyChangedSignal('Text'):Connect(function()
											key.Text = string.format('%d MB', math.floor(tonumber(Hush_CONSTRUCTORS.Memory)));
											task.wait(getgenv().MemorySpooferSettings.MemSpoofer.Delay);
										end);
									end;

								end;
							end
						end)();
					end;
				end;

			end); -- wrap the mem spoofer in a coroutine so incase the waitforchild yields non stop it won't stop further execution of code :D
			Hush_CONSTRUCTORS.Coroutines['MemSpoofing']();
			task.wait(getgenv().MemorySpooferSettings.MemSpoofer.Delay);
		end;
		task.wait();
	end;
end);
Hush_CONSTRUCTORS.Coroutines['MemSpoofer']();
-------------------------------------------
-- Mod Detector --
-------------------------------------------
table.insert(Hush_CONSTRUCTORS.Connections.Misc, RunService.RenderStepped:Connect((function()
	if (getgenv().ModAlert.Mod.Enabled == true) then 
		Hush_CONSTRUCTORS.Coroutines['ModDetector'] = coroutine.wrap(function()
			if (creatorID) then 
				-- Game made by 1 developer
				for index, player in ipairs(Players:GetPlayers()) do 
					if (player.UserId == creatorID) then 
						task.wait(getgenv().ModAlert.Mod.Delay);
						if (string.lower(getgenv().ModAlert.Mod.OnJoin) == 'kick') then 
							Players.LocalPlayer:Kick(getgenv().ModAlert.Mod.Notification);
						elseif (string.lower(getgenv().ModAlert.Mod.OnJoin) == 'Notify') then
							sendNotification('Hush', getgenv().ModAlert.Mod.Notification, 3);
						end;
					end;
				end;
			elseif (groupID) then
				-- Game made by a whole group
				for index, player in ipairs(Players:GetPlayers()) do 
					if player:IsInGroup(groupID) then 
						if player:GetRankInGroup(groupID) >= getgenv().ModAlert.Mod.Rank then 
							if (string.lower(getgenv().ModAlert.Mod.OnJoin) == 'kick') then 
								Players.LocalPlayer:Kick(getgenv().ModAlert.Mod.Notification);
							elseif (string.lower(getgenv().ModAlert.Mod.OnJoin) == 'Notify') then
								sendNotification('Hush', getgenv().ModAlert.Mod.Notification, 3);
							end;
						end
					end;
					task.wait(1); -- wait like 1 second before checking again cause i don't want to get ratelimited
				end;
			end;
		end);
		Hush_CONSTRUCTORS.Coroutines['ModDetector']();
	end;
	task.wait();
end)));
-------------------------------------------
-- Auto Pred --
-------------------------------------------
table.insert(Hush_CONSTRUCTORS.Connections.Misc, RunService.RenderStepped:Connect((function()
	if (getgenv().Hush) and (getgenv().PredictionConfig.Prediction.Automatic.Enabled == true ) then 
		if tostring(getgenv().PredictionConfig.Prediction.Automatic.Mode):lower() == 'advanced' then
			if (Hush_CONSTRUCTORS.Data.Silent_Target and Hush_CONSTRUCTORS.Data.Silent_Target.Character and Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart) and (Players.LocalPlayer.Character and Players.LocalPlayer.Character.PrimaryPart) then
				local Magnitude = (Players.LocalPlayer.Character.PrimaryPart.Position - Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.Position).Magnitude
				local Type = '';
				if (Magnitude >= getgenv().SilentConfigs.Distances.Far) then 
					Type = 'far';
				elseif (Magnitude < getgenv().SilentConfigs.Distances.Far and Magnitude >= getgenv().SilentConfigs.Distances.Mid) then
					Type = 'mid';
				else
					Type = 'close';
				end;
				getgenv().HushConfigSets.Main.SilentPrediction
					= AdvancedPred(Stats.Network.ServerStatsItem['Data Ping']:GetValue(), Type or 'close')
			end;
		elseif tostring(getgenv().PredictionConfig.Prediction.Automatic.Mode):lower() == 'basic' then
			getgenv().HushConfigSets.Main.SilentPrediction
				= 
				-- 30 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 30 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 39) and getgenv().PredictionConfig.Prediction.Automatic.Sets[30] or
				-- 40 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 40 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 49) and getgenv().PredictionConfig.Prediction.Automatic.Sets[40] or
				-- 50 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 50 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 59) and getgenv().PredictionConfig.Prediction.Automatic.Sets[50] or
				-- 60 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 60 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 69) and getgenv().PredictionConfig.Prediction.Automatic.Sets[60] or
				-- 70 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 70 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 79) and getgenv().PredictionConfig.Prediction.Automatic.Sets[70] or
				-- 80 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 80 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 89) and getgenv().PredictionConfig.Prediction.Automatic.Sets[80] or
				-- 90 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 90 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 99) and getgenv().PredictionConfig.Prediction.Automatic.Sets[90] or
				-- 100 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 100 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 109) and getgenv().PredictionConfig.Prediction.Automatic.Sets[100] or
				-- 110 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 110 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 119) and getgenv().PredictionConfig.Prediction.Automatic.Sets[110] or
				-- 120 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 120 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 129) and getgenv().PredictionConfig.Prediction.Automatic.Sets[120] or
				-- 130 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 130 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 139) and getgenv().PredictionConfig.Prediction.Automatic.Sets[130] or
				-- 140 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 140 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 149) and getgenv().PredictionConfig.Prediction.Automatic.Sets[140] or
				-- >140 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 150) and getgenv().PredictionConfig.Prediction.Automatic.Sets[140] + (Stats.Network.ServerStatsItem['Data Ping']:GetValue() / (Stats.Network.ServerStatsItem['Data Ping']:GetValue() - (Stats.Network.ServerStatsItem['Data Ping']:GetValue() - 5) )); -- This is the worst thing i ever made
		end;
	end;
	if (getgenv().Hush) and (getgenv().UseLess.Aimbot.Prediction.Automatic.Enabled == true) then
		if tostring(getgenv().UseLess.Aimbot.Prediction.Automatic.Mode):lower() == 'advanced' then
			if (Hush_CONSTRUCTORS.Data.Lock_Target and Hush_CONSTRUCTORS.Data.Lock_Target.Character and Hush_CONSTRUCTORS.Data.Lock_Target.Character.PrimaryPart) and (Players.LocalPlayer.Character and Players.LocalPlayer.Character.PrimaryPart) then
				local Magnitude = (Players.LocalPlayer.Character.PrimaryPart.Position - Hush_CONSTRUCTORS.Data.Lock_Target.Character.PrimaryPart.Position).Magnitude
				local Type = '';
				if (Magnitude >= getgenv().UseLess.Aimbot.Distances.Far) then 
					Type = 'far';
				elseif (Magnitude < getgenv().UseLess.Aimbot.Distances.Far and Magnitude >= getgenv().UseLess.Aimbot.Distances.Mid) then
					Type = 'mid';
				else
					Type = 'close';
				end;
				getgenv().UseLess.Aimbot.Prediction.Amount = AdvancedPred(Stats.Network.ServerStatsItem['Data Ping']:GetValue(), Type or 'close')
			end;
		elseif tostring(getgenv().UseLess.Aimbot.Prediction.Automatic.Mode):lower() == 'basic' then
			getgenv().UseLess.Aimbot.Prediction.Amount = 
				-- 30 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 30 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 39) and getgenv().UseLess.Aimbot.Prediction.Automatic.Sets[30] or
				-- 40 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 40 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 49) and getgenv().UseLess.Aimbot.Prediction.Automatic.Sets[40] or
				-- 50 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 50 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 59) and getgenv().UseLess.Aimbot.Prediction.Automatic.Sets[50] or
				-- 60 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 60 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 69) and getgenv().UseLess.Aimbot.Prediction.Automatic.Sets[60] or
				-- 70 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 70 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 79) and getgenv().UseLess.Aimbot.Prediction.Automatic.Sets[70] or
				-- 80 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 80 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 89) and getgenv().UseLess.Aimbot.Prediction.Automatic.Sets[80] or
				-- 90 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 90 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 99) and getgenv().UseLess.Aimbot.Prediction.Automatic.Sets[90] or
				-- 100 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 100 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 109) and getgenv().UseLess.Aimbot.Prediction.Automatic.Sets[100] or
				-- 110 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 110 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 119) and getgenv().UseLess.Aimbot.Prediction.Automatic.Sets[110] or
				-- 120 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 120 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 129) and getgenv().UseLess.Aimbot.Prediction.Automatic.Sets[120] or
				-- 130 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 130 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 139) and getgenv().UseLess.Aimbot.Prediction.Automatic.Sets[130] or
				-- 140 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 140 and Stats.Network.ServerStatsItem['Data Ping']:GetValue() <= 149) and getgenv().UseLess.Aimbot.Prediction.Automatic.Sets[140] or
				-- >140 Ping
				(Stats.Network.ServerStatsItem['Data Ping']:GetValue() >= 150) and getgenv().UseLess.Aimbot.Prediction.Automatic.Sets[140] + (Stats.Network.ServerStatsItem['Data Ping']:GetValue() / (Stats.Network.ServerStatsItem['Data Ping']:GetValue() - (Stats.Network.ServerStatsItem['Data Ping']:GetValue() - 5) )); -- This is the worst thing i ever made
		end;
	end;
end)));
-------------------------------------------
-- Anti Log --
-------------------------------------------
table.insert(Hush_CONSTRUCTORS.Connections.Misc, RunService.RenderStepped:Connect((function()
	if (getgenv().Enables.AntiLog == true) then 
		coroutine.wrap(pcall)(function()
			for i, connection in ipairs(getconnections(ScriptContext.Error)) do 
				connection:Disable();
			end
		end);
	end
end)));
-------------------------------------------
-- Triggerbot --
-------------------------------------------
table.insert(Hush_CONSTRUCTORS.Connections.Misc, RunService.RenderStepped:Connect((function()
	if (Hush_CONSTRUCTORS.Booleans.Triggerbot == true) then
		local Shoot = true;
		-- No Pred --
		if (getgenv().Hush) and (getgenv().TriggerBotConfig.Triggerbot.Prediction.Enabled == false) then
			if (getgenv().TriggerBotConfig.Triggerbot.Delay.Enabled == false) then
				-- If player found
				if (Players.LocalPlayer:GetMouse().Target.Parent:FindFirstChildOfClass('Humanoid') or Players.LocalPlayer:GetMouse().Target.Parent.Parent:FindFirstChildOfClass('Humanoid')) then
					-- Declare the player variable
					local Player = Players:GetPlayerFromCharacter(Players.LocalPlayer:GetMouse().Target.Parent) or Players:GetPlayerFromCharacter(Players.LocalPlayer:GetMouse().Target.Parent.Parent);
					-- Checks --

					-- main player check
					if not (Player) then 
						return;
					end;

					-- part check --
					local HitPart = (Players.LocalPlayer:GetMouse().Target):IsA('BasePart') and (Players.LocalPlayer:GetMouse().Target) or (Players.LocalPlayer:GetMouse().Target.Parent):IsA('BasePart') and (Players.LocalPlayer:GetMouse().Target.Parent);
					if (getgenv().TriggerBotConfig.Triggerbot.HitParts ~= true) then 
						if not table.find(getgenv().TriggerBotConfig.Triggerbot.HitParts, HitPart.Name) then 
							Shoot = false;
						end;
					end;

					-------------------------------------------
					-- TEAM CHECK --
					-------------------------------------------
					if (getgenv().Checks.Checks.Teamcheck == true) then 
						if (Player.Team == Players.LocalPlayer.Team) then 
							Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
						end;
					end;
					-------------------------------------------
					-- WHITELISTED --
					-------------------------------------------
					if (getgenv().Checks.Checks.Whitelisted == true) then 
						if table.find(getgenv().Whitelisted.Whitelisted, Player.Name) then 
							Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
						end;
					end;
					-------------------------------------------
					-- FRIENDS --
					-------------------------------------------
					if (getgenv().Checks.Checks.Friends == true) then 
						if Player:IsFriendsWith(Players.LocalPlayer.UserId) then 
							Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
						end;
					end;
					-------------------------------------------
					-- DEAD --
					-------------------------------------------
					if (getgenv().Checks.Checks.Dead == true) then 
						if (Player:FindFirstChildOfClass('Humanoid') ~= nil and Player:FindFirstChildOfClass('Humanoid').Health <= 3) then 
							Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
						end
					end;
					-------------------------------------------
					-- LOCALPLAYER --
					-------------------------------------------
					if (getgenv().Checks.Checks.LocalPlayer == true) then 
						if Player == Players.LocalPlayer then 
							Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
						end;
					end;

					-------------------------------------------
					-- RADIUS --
					-------------------------------------------
					if (getgenv().TriggerBotConfig.Triggerbot.Radius.Enabled == true) then
						-- thanks Hush get nearest function
						-- gg

						local MousePos = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y);
						local PartPos = Player.Character.PrimaryPart.Position;
						local OnScreenPos = workspace.CurrentCamera:WorldToScreenPoint(PartPos);
						local DisOnScreen = CompareDis(MousePos, Vector2.new(OnScreenPos.X, OnScreenPos.Y));
						if (DisOnScreen > getgenv().TriggerBotConfig.Triggerbot.Radius.Amount) then
							Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
						end;
					end;
					-------------------------------------------
					-- Shooting --

					if (Shoot == true) then
						if (string.lower(getgenv().TriggerBotConfig.Triggerbot.Mode) == 'legit') then 
							mouse1click();
						elseif (string.lower(getgenv().TriggerBotConfig.Triggerbot.Mode) == 'blatant') then
							coroutine.wrap(function() 
								repeat
									mouse1press();
									task.wait();
								until Player == nil;
								mouse1release();
							end)();
						end;
					end;
				end;
			else
				-- If player found
				if (Players.LocalPlayer:GetMouse().Target.Parent:FindFirstChildOfClass('Humanoid')) then
					-- Declare the player variable
					local Player = Players:GetPlayerFromCharacter(Players.LocalPlayer:GetMouse().Target.Parent);
					-- Checks --

					-------------------------------------------
					-- TEAM CHECK --
					-------------------------------------------
					if (getgenv().Checks.Checks.Teamcheck == true) then 
						if (Player.Team == Players.LocalPlayer.Team) then 
							Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
						end;
					end;
					-------------------------------------------
					-- WHITELISTED --
					-------------------------------------------
					if (getgenv().Checks.Checks.Whitelisted == true) then 
						if table.find(getgenv().Whitelisted.Whitelisted, Player.Name) then 
							Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
						end;
					end;
					-------------------------------------------
					-- FRIENDS --
					-------------------------------------------
					if (getgenv().Checks.Checks.Friends == true) then 
						if Player:IsFriendsWith(Players.LocalPlayer.UserId) then 
							Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
						end;
					end;
					-------------------------------------------
					-- DEAD --
					-------------------------------------------
					if (getgenv().Checks.Checks.Dead == true) then 
						if (Player:FindFirstChildOfClass('Humanoid') ~= nil and Player:FindFirstChildOfClass('Humanoid').Health <= 3) then 
							Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
						end
					end;
					-------------------------------------------
					-- LOCALPLAYER --
					-------------------------------------------
					if (getgenv().Checks.Checks.LocalPlayer == true) then 
						if Player == Players.LocalPlayer then 
							Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
						end;
					end;

					-------------------------------------------

					-- Shooting --

					if (Shoot == true) then
						if (string.lower(getgenv().TriggerBotConfig.Triggerbot.Mode) == 'legit') then 
							mouse1click();
							task.wait(getgenv().TriggerBotConfig.Triggerbot.Delay.Delay / 1000);
						elseif (string.lower(getgenv().TriggerBotConfig.Triggerbot.Mode) == 'blatant') then
							coroutine.wrap(function() 
								repeat
									mouse1press();
									task.wait(getgenv().TriggerBotConfig.Triggerbot.Delay.Delay / 1000);
								until Player == nil;
								mouse1release();
							end)();
						end;
					end;
				end;
				-- End of checking (no pred) --
				-------------------------------------------
			end;
		elseif (getgenv().Hush) and (getgenv().TriggerBotConfig.Triggerbot.Prediction.Enabled == true) then
			-- FULL PRED --
			if (getgenv().TriggerBotConfig.Triggerbot.Delay.Enabled == false) then
				if (Hush_CONSTRUCTORS.Data.Trigger_Target ~= nil and Hush_CONSTRUCTORS.Data.Trigger_Target.Character ~= nil) then 
					if (Hush_CONSTRUCTORS.Data.Trigger_Target.Character.PrimaryPart) then 
						local HitPart = Hush_CONSTRUCTORS.Data.Trigger_Target.Character.PrimaryPart;
						-- please let primarypart slide you fucking retards --
						-- swear to god you config makers are always dumbasses --
						if (getgenv().TriggerBotConfig.Triggerbot.HitParts ~= true) then 
							if not table.find(getgenv().TriggerBotConfig.Triggerbot.HitParts, HitPart.Name) then 
								Shoot = false;
							end;
						end;

						-------------------------------------------
						-- TEAM CHECK --
						-------------------------------------------
						if (getgenv().Checks.Checks.Teamcheck == true) then 
							if (Hush_CONSTRUCTORS.Data.Trigger_Target.Team == Players.LocalPlayer.Team) then 
								Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
							end;
						end;
						-------------------------------------------
						-- WHITELISTED --
						-------------------------------------------
						if (getgenv().Checks.Checks.Whitelisted == true) then 
							if table.find(getgenv().Whitelisted.Whitelisted, Hush_CONSTRUCTORS.Data.Trigger_Target.Name) then 
								Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
							end;
						end;
						-------------------------------------------
						-- FRIENDS --
						-------------------------------------------
						if (getgenv().Checks.Checks.Friends == true) then 
							if Hush_CONSTRUCTORS.Data.Trigger_Target:IsFriendsWith(Players.LocalPlayer.UserId) then 
								Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
							end;
						end;
						-------------------------------------------
						-- DEAD --
						-------------------------------------------
						if (getgenv().Checks.Checks.Dead == true) then 
							if (Hush_CONSTRUCTORS.Data.Trigger_Target.Character:FindFirstChildOfClass('Humanoid') ~= nil and Hush_CONSTRUCTORS.Data.Trigger_Target.Character:FindFirstChildOfClass('Humanoid').Health <= 3) then 
								Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
							end
						end;
						-------------------------------------------
						-- LOCALPLAYER --
						-------------------------------------------
						if (getgenv().Checks.Checks.LocalPlayer == true) then 
							if Hush_CONSTRUCTORS.Data.Trigger_Target == Players.LocalPlayer then 
								Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
							end;
						end;

						-------------------------------------------
						if (Shoot == true) then
							if (string.lower(getgenv().TriggerBotConfig.Triggerbot.Mode) == 'legit') then 
								mouse1click();
							elseif (string.lower(getgenv().TriggerBotConfig.Triggerbot.Mode) == 'blatant') then
								coroutine.wrap(function() 
									repeat
										mouse1press();
										task.wait();
									until Hush_CONSTRUCTORS.Data.Trigger_Target == nil;
									mouse1release();
								end)();
							end;
						end;

					end;
				end;

				-- No Delay
			elseif (getgenv().TriggerBotConfig.Triggerbot.Delay.Enabled == true) then
				if (Hush_CONSTRUCTORS.Data.Trigger_Target ~= nil and Hush_CONSTRUCTORS.Data.Trigger_Target.Character ~= nil) then 
					if (Hush_CONSTRUCTORS.Data.Trigger_Target.Character.PrimaryPart) then 
						local HitPart = Hush_CONSTRUCTORS.Data.Trigger_Target.Character.PrimaryPart;
						-- please let primarypart slide you fucking retards --
						-- swear to god you config makers are always dumbasses --
						if (getgenv().TriggerBotConfig.Triggerbot.HitParts ~= true) then 
							if not table.find(getgenv().TriggerBotConfig.Triggerbot.HitParts, HitPart.Name) then 
								Shoot = false;
							end;
						end;
						-- TEAM CHECK --
						-------------------------------------------
						if (getgenv().Checks.Checks.Teamcheck == true) then 
							if (Hush_CONSTRUCTORS.Data.Trigger_Target.Team == Players.LocalPlayer.Team) then 
								Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
							end;
						end;
						-------------------------------------------
						-- WHITELISTED --
						-------------------------------------------
						if (getgenv().Checks.Checks.Whitelisted == true) then 
							if table.find(getgenv().Whitelisted.Whitelisted, Hush_CONSTRUCTORS.Data.Trigger_Target.Name) then 
								Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
							end;
						end;
						-------------------------------------------
						-- FRIENDS --
						-------------------------------------------
						if (getgenv().Checks.Checks.Friends == true) then 
							if Hush_CONSTRUCTORS.Data.Trigger_Target:IsFriendsWith(Players.LocalPlayer.UserId) then 
								Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
							end;
						end;
						-------------------------------------------
						-- DEAD --
						-------------------------------------------
						if (getgenv().Checks.Checks.Dead == true) then 
							if (Hush_CONSTRUCTORS.Data.Trigger_Target.Character:FindFirstChildOfClass('Humanoid') ~= nil and Hush_CONSTRUCTORS.Data.Trigger_Target.Character:FindFirstChildOfClass('Humanoid').Health <= 3) then 
								Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
							end
						end;
						-------------------------------------------
						-- LOCALPLAYER --
						-------------------------------------------
						if (getgenv().Checks.Checks.LocalPlayer == true) then 
							if Hush_CONSTRUCTORS.Data.Trigger_Target == Players.LocalPlayer then 
								Shoot = false; -- retrieve the shoot upvalue and set it to false (this will be used later cuz i don't wanna make it return smth if its not valid)
							end;
						end;

						-------------------------------------------
						if (Shoot == true) then
							if (string.lower(getgenv().TriggerBotConfig.Triggerbot.Mode) == 'legit') then 
								mouse1click();
								task.wait(getgenv().TriggerBotConfig.Triggerbot.Delay.Delay / 1000);
							elseif (string.lower(getgenv().TriggerBotConfig.Triggerbot.Mode) == 'blatant') then
								coroutine.wrap(function() 
									repeat
										mouse1press();
										task.wait(getgenv().TriggerBotConfig.Triggerbot.Delay.Delay / 1000);
									until Hush_CONSTRUCTORS.Data.Trigger_Target == nil;
									mouse1release();
								end)();
							end;
						end;
					end;
				end;
			end;
		end;
	end;
end)));
-------------------------------------------

-------------------------------------------
-- Watermark --
-------------------------------------------
Hush_CONSTRUCTORS.Assets['Watermark'] = Drawing.new('Text');
Hush_CONSTRUCTORS.Assets['Watermark'].Font = Drawing.Fonts.Plex;
Hush_CONSTRUCTORS.Assets['Watermark'].Size = 22;
Hush_CONSTRUCTORS.Assets['Watermark'].Visible = false;
Hush_CONSTRUCTORS.Assets['Watermark'].Text = 'Hush.CC';
Hush_CONSTRUCTORS.Assets['Watermark'].Position = Vector2.new(15, 15);
table.insert(Hush_CONSTRUCTORS.Connections.Misc, RunService.RenderStepped:Connect((function()
	Hush_CONSTRUCTORS.Assets['Watermark'].Visible = getgenv().WaterMarkSettings.Watermark.Enabled;
end)));
-------------------------------------------
-- FOV --
-------------------------------------------
-- Silent --
Hush_CONSTRUCTORS.Assets['FOV_Silent'] = Drawing.new('Circle');
-- Lock --
Hush_CONSTRUCTORS.Assets['FOV_Lock'] = Drawing.new('Circle');
-------------------------------------------
-- Silent --
Hush_CONSTRUCTORS.Assets['FOV_Silent'].Visible = false;
-- Lock --
Hush_CONSTRUCTORS.Assets['FOV_Lock'].Visible = false;
-------------------------------------------
Hush_CONSTRUCTORS.Coroutines['FOV'] = coroutine.wrap(function()
	-------------------------------------------
	-- Declare float variables --
	-------------------------------------------
	local SilentHue = 0;
	local LockHue = 0;
	-------------------------------------------
	while (true) and (getgenv().Hush) do
		-- Float checking --
		if (SilentHue >= 1) then 
			SilentHue = 0;
		end;
		if (LockHue >= 1) then
			LockHue = 0;
		end;
		-- Silent --
		if (getgenv().FOV.Main.Faggot == true) then
			Hush_CONSTRUCTORS.Assets['FOV_Silent'].Color = Color3.fromHSV(SilentHue, 1, 1);
			SilentHue = SilentHue + 0.01
		elseif (getgenv().FOV.Main.Faggot == false) then
			Hush_CONSTRUCTORS.Assets['FOV_Silent'].Color = getgenv().FOV.Main.Color;
		else
			Hush_CONSTRUCTORS.Assets['FOV_Silent'].Color = getgenv().FOV.Main.Color;
		end;
		-- Lock --
		if (getgenv().UseLess.Aimbot.FOV.Rainbow == true) then
			Hush_CONSTRUCTORS.Assets['FOV_Lock'].Color = Color3.fromHSV(LockHue, 1, 1);
			LockHue = LockHue + 0.01
		elseif (getgenv().UseLess.Aimbot.FOV.Rainbow == false) then
			Hush_CONSTRUCTORS.Assets['FOV_Lock'].Color = getgenv().UseLess.Aimbot.FOV.Color;
		else
			Hush_CONSTRUCTORS.Assets['FOV_Lock'].Color = getgenv().UseLess.Aimbot.FOV.Color;
		end;
		---------------------------------------------------------------
		task.wait(getgenv().UseLess.Aimbot.FOV.RainbowSpeed);
	end;
end);
Hush_CONSTRUCTORS.Coroutines['FOV']();
table.insert(Hush_CONSTRUCTORS.Connections.Misc, RunService.RenderStepped:Connect((function()
	-------------------------------------------
	-- Silent FOV --
	-------------------------------------------
	Hush_CONSTRUCTORS.Assets['FOV_Silent'].Thickness = getgenv().FOV.Main.FovTightness or 1;
	Hush_CONSTRUCTORS.Assets['FOV_Silent'].NumSides = getgenv().FOV.Main.SidesScaleCalculation or 64;
	Hush_CONSTRUCTORS.Assets['FOV_Silent'].Radius = 	getgenv().HushConfigSets.Main.SilentRadius
	;
	Hush_CONSTRUCTORS.Assets['FOV_Silent'].Filled = getgenv().FOV.Main.Filled or false;
	Hush_CONSTRUCTORS.Assets['FOV_Silent'].Visible = (getgenv().FOV.Main.Enabled
		== true and getgenv().FOV.Main.Circle == true and true or false);
	-------------------------------------------
	-- Lock FOV --
	-------------------------------------------
	Hush_CONSTRUCTORS.Assets['FOV_Lock'].Thickness = getgenv().UseLess.Aimbot.FOV.Thickness or 1;
	Hush_CONSTRUCTORS.Assets['FOV_Lock'].NumSides = getgenv().UseLess.Aimbot.FOV.NumSides or 64;
	Hush_CONSTRUCTORS.Assets['FOV_Lock'].Radius = getgenv().UseLess.Aimbot.FOV.Radius;
	Hush_CONSTRUCTORS.Assets['FOV_Lock'].Filled = getgenv().UseLess.Aimbot.FOV.Filled or false;
	Hush_CONSTRUCTORS.Assets['FOV_Lock'].Visible = getgenv().UseLess.Aimbot.FOV.Enabled or false;
	-------------------------------------------
	-- Positioning --
	-------------------------------------------
	Hush_CONSTRUCTORS.Assets['FOV_Lock'].Position, Hush_CONSTRUCTORS.Assets['FOV_Silent'].Position = UserInputService:GetMouseLocation(), UserInputService:GetMouseLocation(); -- woohoo fixed position cause mouse.hit.p is hooked and also inaccurate pos for the circle wooho!!
end)));
-------------------------------------------
if (getgenv().Enables.UnlockFPS == true) then 
	setfpscap(0);
end;
-------------------------------------------
-------------------------------------------
-- Silent --
-------------------------------------------
table.insert(Hush_CONSTRUCTORS.Connections.Misc, RunService.RenderStepped:Connect((function()
	-- Silent
	Hush_CONSTRUCTORS.Data.Silent_Target = GetNearestPlayer('silent');
	-- Triggerbot
	Hush_CONSTRUCTORS.Data.Trigger_Target = GetNearestPlayer('triggerbot');
end)));
-------------------------------------------
-- In-Game Commands --
-------------------------------------------
Players.LocalPlayer.Chatted:Connect(function(Msg)
	if string.lower((Msg):sub(#getgenv().ChatCmds.Commands.Prefix, #getgenv().ChatCmds.Commands.Prefix)) == string.lower(getgenv().ChatCmds.Commands.Prefix) then 
		-- User 100% is meant to run a Hush command
		local Msg = Msg:sub(2);
		local Args = {};

		for String in Msg:gmatch('%S+') do 
			table.insert(Args, String);
		end;

		local Command = string.lower(Args[1]);

		-- Silent Commands --
		-------------------------------------
		-- Set Pred --
		if (Command == getgenv().ChatCmds.Commands.Silent.SetPredAmount) then
			-- Silent pred setter --
			if (#Args < 2) then 
				return;
			end;
			local Pred = tonumber(Args[2]);
			if Pred then 
				getgenv().HushConfigSets.Main.SilentPrediction
					= Pred;
			end;
			-------------------------------------
			-- Set FOV size --
		elseif (Command == getgenv().ChatCmds.Commands.Silent.SetFOV) then
			-- Silent fov setter --
			if (#Args < 2) then 
				return;
			end;
			local Size = tonumber(Args[2]);
			if Size then 
				getgenv().HushConfigSets.Main.SilentRadius
					= Size;
			end;
			-------------------------------------
			-- Disable FOV --
		elseif (Command == getgenv().ChatCmds.Commands.Silent.DisableFOV) then
			-- Silent FOV setter --
			-- Silent on / off --
			getgenv().FOV.Main.Enabled
				= false;
			-------------------------------------
			-- Enable FOV --
		elseif (Commnad == getgenv().ChatCmds.Commands.Silent.EnableFOV) then
			-- Silent FOV setter --
			-- Silent on / off --
			getgenv().FOV.Main.Enabled
				= true;
			-------------------------------------
			-- Enable Silent --
		elseif (Command == getgenv().ChatCmds.Commands.Silent.SetSilent) then
			-- Silent on / off --
			if (#Args < 2) then 
				return;
			end;
			local Status = string.lower(tostring(Args[2]));
			if (Status == 'on') then 
				getgenv().Enables.Silent = true;
			else
				getgenv().Enables.Silent = false;
			end;
			-------------------------------------
			-- Silent Auto rotate --
		elseif (Command == getgenv().ChatCmds.Commands.Silent.SetRotate) then
			-- Silent rotate on / off --
			if (#Args < 2) then 
				return;
			end;
			local Status = string.lower(tostring(Args[2]));
			if (Status == 'on') then 
				getgenv().SilentConfigs.RotateToSilentTarget = true;
			else
				getgenv().SilentConfigs.RotateToSilentTarget = false;
			end;
			----------------------------------------------
			-- Auto Pred --
		elseif (Command == getgenv().ChatCmds.Commands.Silent.SetAutoPred) then
			-- Silent auto pred on / off --
			if (#Args < 2) then 
				return;
			end;
			local Status = string.lower(tostring(Args[2]));
			if (Status == 'on') then 
				getgenv().PredictionConfig.Prediction.Automatic = true;
			else
				getgenv().PredictionConfig.Prediction.Automatic = false;
			end;
			----------------------------------------------
			-- Auto Pred mode --
		elseif (Command == getgenv().ChatCmds.Commands.Silent.SetAutoPredMode) then
			-- Silent auto pred mode --
			if (#Args < 2) then 
				return;
			end;
			local Status = string.lower(tostring(Args[2]));
			if (Status == 'advanced') then 
				getgenv().PredictionConfig.Prediction.Automatic.Mode = 'Advanced';
			else
				getgenv().PredictionConfig.Prediction.Automatic.Mode = Status;
			end;
			-------------------------------------
			-- Hit method --
		elseif (Command == getgenv().ChatCmds.Commands.Silent.SetHitMethod) then
			-- Hit part method --
			if (#Args < 2) then 
				return;
			end;
			local Method = tonumber(Args[2]);
			getgenv().HittingChance.Main.Hitting = Method or 0;
			-------------------------------------
			-- Set miss --
		elseif (Command == getgenv().ChatCmds.Commands.Silent.SetMiss) then
			-- Hit miss method --
			if (#Args < 2) then 
				return;
			end;
			local Status = string.lower(tostring(Args[2]));
			if (Status == 'on') then 
				getgenv().SilentLegitSettings.Miss.Enabled = true;
			else
				getgenv().SilentLegitSettings.Miss.Enabled = false;
			end;
			-- Bad Talk
		elseif (Command == getgenv().ChatCmds.Commands.BadTalk.RemoveAll) then
			-- Remove all bad phrases --
			getgenv().ShitTalkingConfig.ShitTalk.Phrases = {};
			-------------------------------------
			-- Remove phrase from table with index --
		elseif (Command == getgenv().ChatCmds.Commands.BadTalk.RemovePhrase) then
			if (#Args < 2) then 
				return;
			end;
			local Index = tonumber(Args[2]);
			if getgenv().ShitTalkingConfig.ShitTalk.Phrases[Index] ~= nil then 
				getgenv().ShitTalkingConfig.ShitTalk.Phrases[Index] = nil;
			end;
			-------------------------------------
			-- Add base64 decoded phrase --
		elseif (Command == getgenv().ChatCmds.Commands.BadTalk.AddPhrase) then
			if (#Args < 3) then 
				return;
			end;
			local Index = tonumber(Args[2]);
			local String = tostring(Args[3]);

			local RawString = base64_decode(String);
			if getgenv().ShitTalkingConfig.ShitTalk.Phrases[Index] ~= nil then 
				getgenv().ShitTalkingConfig.ShitTalk.Phrases[Index] = RawString;
			end;
		end;
		-------------------------------------
		-- Lock Commands --
		if (Command == getgenv().ChatCmds.Commands.Lock.SetPredAmount) then 
			-- Lock pred setter --
			if (#Args < 2) then 
				return;
			end;
			local Pred = tonumber(Args[2]);
			if Pred then 
				getgenv().UseLess.Aimbot.Prediction.Amount = Pred;
			end;
			-------------------------------------
			-- Lock FOV size setter --
		elseif (Command == getgenv().ChatCmds.Commands.Lock.SetFOV) then
			-- Lock fov setter --
			if (#Args < 2) then 
				return;
			end;
			local Size = tonumber(Args[2]);
			if Size then 
				getgenv().UseLess.Aimbot.FOV.Radius = Size;
			end;
			-------------------------------------
			-- Lock FOV Disabler --
		elseif (Command == getgenv().ChatCmds.Commands.Lock.DisableFOV) then
			-- Lock FOV setter --
			-- Lock on / off --
			getgenv().UseLess.Aimbot.FOV.Enabled = false;
			-------------------------------------
			-- Lock FOV Enabler --
		elseif (Command == getgenv().ChatCmds.Commands.Lock.EnableFOV) then
			-- Lock FOV setter --
			-- Lock on / off --
			getgenv().UseLess.Aimbot.FOV.Enabled = true;
			-------------------------------------
			-- Lock Auto Pred --
		elseif (Command == getgenv().ChatCmds.Commands.Lock.SetAutoPred) then
			-- Lock auto pred on / off --
			if (#Args < 2) then 
				return;
			end;
			local Status = string.lower(tostring(Args[2]));
			if (Status == 'on') then 
				getgenv().UseLess.Aimbot.Prediction.Automatic.Enabled = true;
			else
				getgenv().UseLess.Aimbot.Prediction.Automatic.Enabled = false;
			end;
			-------------------------------------
			-- Lock Auto Pred mode --
		elseif (Command == getgenv().ChatCmds.Commands.Lock.SetAutoPredMode) then
			-- Lock auto pred mode --
			if (#Args < 2) then 
				return;
			end;
			local Status = string.lower(tostring(Args[2]));
			if (Status == 'advanced') then 
				getgenv().UseLess.Aimbot.Prediction.Automatic.Mode = 'Advanced';
			else
				getgenv().UseLess.Aimbot.Prediction.Automatic.Mode = Status;
			end;
			-------------------------------------
			-- Enable Lock --
		elseif (Command == getgenv().ChatCmds.Commands.Lock.SetLock) then
			if (#Args < 2) then 
				return;
			end;
			local Status = string.lower(tostring(Args[2]));
			if (Status == 'on') then 
				getgenv().Enables.Lock = true;
			else
				getgenv().Enables.Lock = false;
			end;
			-------------------------------------
			-- Auto Lock Rotate --
		elseif (Command == getgenv().ChatCmds.Commands.Lock.SetRotate) then
			-- Lock rotate on / off --
			if (#Args < 2) then 
				return;
			end;
			local Status = string.lower(tostring(Args[2]));
			if (Status == 'on') then 
				getgenv().UseLess.Aimbot.RotateChar = true;
			else
				getgenv().UseLess.Aimbot.RotateChar = false;
			end;
			-------------------------------------
			-- Lock Hit method --
		elseif (Command == getgenv().ChatCmds.Commands.Lock.SetHitMethod) then
			-- Hit part method --
			if (#Args < 2) then 
				return;
			end;
			local Method = tonumber(Args[2]);
			getgenv().UseLess.Aimbot.Hitting = Method or 0;
		end;


		-------------------------------------
		-- Misc Commands --
		-------------------------------------
		-- REJOIN --
		if (Command == getgenv().ChatCmds.Commands.Misc.Rejoin) then 
			TeleportService:Teleport(game.PlaceId, game.JobId, Players.LocalPlayer);
		elseif (Command == getgenv().ChatCmds.Commands.Misc.Reset) and (Players.LocalPlayer.Character) then
			for i, v in ipairs(Players.LocalPlayer.Character:GetChildren()) do 
				if (v:IsA('Accessory') or v:IsA('BasePart') or v:IsA('Part') or v:IsA('SpecialMesh') or v:IsA('MeshPart')) then 
					v:Remove();
				end;
			end;
			-------------------------------------
			-- RESOLVER --
			-------------------------------------
		elseif (Command == getgenv().ChatCmds.Commands.Misc.Resolver) then
			if (#Args < 2) then 
				return;
			end;
			local Status = string.lower(tostring(Args[2]));
			if (Status == 'on') then 
				getgenv().SilentConfigs.AutomaticResolver = true;
			else
				getgenv().SilentConfigs.AutomaticResolver = false;
			end;
			-------------------------------------
			-- SET PREFIX --
			-------------------------------------
		elseif (Command == getgenv().ChatCmds.Commands.Misc.SetPrefix) then
			if (#Args < 2) then 
				return;
			end;
			local NewPrefix = tostring(Args[2]);
			getgenv().ChatCmds.Commands.Prefix = NewPrefix;
		end;
		-------------------------------------
		-------------------------------------
	end;
end);

local grmt = getrawmetatable(game)
local backupindex = grmt.__index
setreadonly(grmt, false)
local properties = {
	"Hit"
}


(function()

	if (getgenv().Enables.BypassDaHood == true) and (getgenv().Enables.BypassAdonis == false) then
		-- This will be so laggy
		grmt.__index = newcclosure(function(self, ...) 
			local NamecallArgs = {...};

			local DETECTION_STRINGS = 
				{
					'CHECKER_1';
					'CHECKER';
					'OneMoreTime';
					'checkingSPEED';
					'PERMAIDBAN';
					'BANREMOTE';
					'FORCEFIELD';
					'TeleportDetect';
				};

			if (table.find(DETECTION_STRINGS, NamecallArgs[1]) and getnamecallmethod() == 'FireServer') then 
				return;
			end;
			local suc, err = pcall(getfenv, 2);
			if not (err) then 
				if getfenv(2).crash then 
					hookfunction(getfenv(2).crash, function() 

					end);
				end;
			end;
			return backupindex(self, ...);
		end);
	end;
	grmt.__index = newcclosure(function(self, idx)
		if Mouse and table.find(properties, idx) then
			-- Prevent shit index hooks (so game.Hit won't return an actual value (as it's nil) )
			local HitChance = HitChanceGen(getgenv().SilentLegitSettings.HitChance.Chance, getgenv().SilentLegitSettings.HitChance.Intensity);
			----------------------------------------
			local Resolver = false;

			local Data = {
				Positions = {
					Last = nil;
					Current = nil;
				};
				Time      = {
					Last = nil;
					Current = nil;
				};
			};
			----------------------------------------
			if (getgenv().SilentLegitSettings.HitChance.Enabled == true) and (Hush_CONSTRUCTORS.Data.Silent_Target) and (Hush_CONSTRUCTORS.Booleans.Silent == true) then 
				if (HitChance == true) then
					----------------------------------------
					-- Resolver --
					if (getgenv().SilentConfigs.AutomaticResolver == true) then 
						if (Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.Velocity.X >= 35 or Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.Velocity.Y >= 20 or Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.Velocity.Z >= 35 or Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.Velocity.X <= -30 or Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.Velocity.Y <= -25 or Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.Velocity.Z <= -30) then 
							Resolver = true;
						end;
					end;
					----------------------------------------
					coroutine.wrap(function()
						if (Hush_CONSTRUCTORS.Data.Silent_Target) and (Hush_CONSTRUCTORS.Data.Silent_Target ~= nil and Hush_CONSTRUCTORS.Data.Silent_Target.Character) then
							pcall(function()
								Data.Positions.Last = Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.Position;
								Data.Time.Last = tick();
								---------------------------------------
								wait(0.00350);
								---------------------------------------
								Data.Positions.Current = Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.Position;
								Data.Time.Current = tick();
							end);
						end;
					end)();
					----------------------------------------
					local SelectedPart = (
						getgenv().HittingChance.Main.Hitting == 0 and GetNearestPoint(Hush_CONSTRUCTORS.Data.Silent_Target.Character) or
							getgenv().HittingChance.Main.Hitting == 1 and Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart or
							getgenv().HittingChance.Main.Hitting == 2 and Hush_CONSTRUCTORS.Data.Silent_Target.Character[getgenv().SilentConfigs.BasePart] or
							getgenv().HittingChance.Main.Hitting == 3 and Hush_CONSTRUCTORS.Data.Silent_Target.Character:children()[math.random(1, #Hush_CONSTRUCTORS.Data.Silent_Target.Character:children())] or
							Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart
					) or Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart or Hush_CONSTRUCTORS.Data.Silent_Target.Character.HumanoidRootPart;
					if (Resolver == true) then
						SelectedPart.Velocity = Vector3.new(
							-- X Axis
							0 + (
								-- V1
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'MoveDirection' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.MoveDirection * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred == true and math.random(1.25, 2) or getgenv().SilentConfigs.Resolver.MoveDirection).X
									or
									-- V2
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'LookVector' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.CFrame.LookVector * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
									== true and math.random(1.15, 2) or getgenv().SilentConfigs.Resolver.LookVector).X
									or
									-- V3
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'SkidStyle' and 0
									or
									-- V4
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().SilentConfigs.Resolver.Delta / 100) ).X
									or
									-- V ?
									0

							),
							-- Y Axis
							0 + (
								-- V1
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'MoveDirection' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.MoveDirection * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
									== true and math.random(1.25, 2) or getgenv().SilentConfigs.Resolver.MoveDirection).Y
									or
									-- V2
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'LookVector' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.CFrame.LookVector * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
									== true and math.random(1.15, 2) or getgenv().SilentConfigs.Resolver.LookVector).Y
									or
									-- V3
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'SkidStyle' and 0
									or
									-- V4
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().SilentConfigs.Resolver.Delta / 100) ).Y
									or
									-- V ?
									0

							),
							-- Z Axis
							0 + (
								-- V1
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'MoveDirection' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.MoveDirection * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
									== true and math.random(1.25, 2) or getgenv().SilentConfigs.Resolver.MoveDirection).Z
									or
									-- V2
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'LookVector' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.CFrame.LookVector * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
									== true and math.random(1.15, 2) or getgenv().SilentConfigs.Resolver.LookVector).Z
									or
									-- V3
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'SkidStyle' and 0
									or
									-- V4
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().SilentConfigs.Resolver.Delta / 100) ).Z
									or
									-- V ?
									0

							)
						);
						SelectedPart.AssemblyLinearVelocity = Vector3.new(
							-- X Axis
							0 + (
								-- V1
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'MoveDirection' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.MoveDirection * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
									== true and math.random(1.25, 2) or getgenv().SilentConfigs.Resolver.MoveDirection).X
									or
									-- V2
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'LookVector' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.CFrame.LookVector * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
									== true and math.random(1.15, 2) or getgenv().SilentConfigs.Resolver.LookVector).X
									or
									-- V3
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'SkidStyle' and 0
									or
									-- V4
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().SilentConfigs.Resolver.Delta / 100) ).X
									or
									-- V ?
									0

							),
							-- Y Axis
							0 + (
								-- V1
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'MoveDirection' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.MoveDirection * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
									== true and math.random(1.25, 2) or getgenv().SilentConfigs.Resolver.MoveDirection).Y
									or
									-- V2
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'LookVector' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.CFrame.LookVector * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
									== true and math.random(1.15, 2) or getgenv().SilentConfigs.Resolver.LookVector).Y
									or
									-- V3
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'SkidStyle' and 0
									or
									-- V4
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().SilentConfigs.Resolver.Delta / 100) ).Y
									or
									-- V ?
									0

							),
							-- Z Axis
							0 + (
								-- V1
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'MoveDirection' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.MoveDirection * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
									== true and math.random(1.25, 2) or getgenv().SilentConfigs.Resolver.MoveDirection).Z
									or
									-- V2
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'LookVector' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.CFrame.LookVector * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
									== true and math.random(1.15, 2) or getgenv().SilentConfigs.Resolver.LookVector).Z
									or
									-- V3
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'SkidStyle' and 0
									or
									-- V4
									tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().SilentConfigs.Resolver.Delta / 100) ).Z
									or
									-- V ?
									0

							)
						);
					end;
					-- Predicted Pos --
					local MissChanceGen = function(Percentage) 
						return math.random() <= (Percentage / 100);
					end;
					if (	getgenv().SilentLegitSettings.Miss.Enabled == true) then 
						local Miss = MissChanceGen(	getgenv().SilentLegitSettings.Miss.Chance);
						if (Miss == true) then 
							SelectedPart.Velocity = SelectedPart.Velocity + Vector3.new(

								-- X Axis
								math.random(	getgenv().SilentLegitSettings.Miss.Intensity.X[1], 	getgenv().SilentLegitSettings.Miss.Intensity.X[2]),
								-- Y Axis
								math.random(	getgenv().SilentLegitSettings.Miss.Intensity.Y[1], 	getgenv().SilentLegitSettings.Miss.Intensity.Y[2]),
								-- Z Axis
								math.random(	getgenv().SilentLegitSettings.Miss.Intensity.Z[1], 	getgenv().SilentLegitSettings.Miss.Intensity.Z[2])
							);
						end;
					end;

					local HOOK_POS = true;

					local Predicted_Pos = SelectedPart.Position + SelectedPart.Velocity * (getgenv().PredictionConfig.Prediction.Enabled == true and getgenv().HushConfigSets.Main.SilentPrediction
						or 1);
					local OnScreenPos = workspace.CurrentCamera:WorldToViewportPoint(Predicted_Pos);
					OnScreenPos = CFrame.new(OnScreenPos);
					-- Tracer --
					-- Return & Etc --
					if (getgenv().SilentConfigs.RotateToSilentTarget == true) then 
						Players.LocalPlayer.Character.PrimaryPart.CFrame = CFrame.lookAt(Players.LocalPlayer.Character.PrimaryPart.Position, Predicted_Pos);
					end;
					-------------------------------------
					-- Self Reloading --
					if (getgenv().Checks.Checks.Reloading == true) then 
						if (Players.LocalPlayer.Character.BodyEffects ~= nil and Players.LocalPlayer.Character.BodyEffects.Reload.Value == true) then 
							HOOK_POS = false;
						end;
					else
						HOOK_POS = HOOK_POS;
					end;
					-- Grabbing --
					if (getgenv().Checks.Checks.Grabbing == true) then 
						if (Hush_CONSTRUCTORS.Data.Silent_Target.Character and Hush_CONSTRUCTORS.Data.Silent_Target.Character:FindFirstChild('GRABBING_CONSTRAINT')) then 
							HOOK_POS = false;
						end;
					end;
					-------------------------------------
					if (getgenv().StrafeConfig.Strafe.Enabled == true) then
						Hush_CONSTRUCTORS.Coroutines['SilentStrafe'] = coroutine.wrap(function()
							local Degree_X = 0;
							pcall(function()
								while (true) and (getgenv().Hush) and (Hush_CONSTRUCTORS.Booleans.Strafe == true) do
									Degree_X = Degree_X + 1
									if (Degree_X >= 360) then 
										Degree_X = 0;
									end;
									if (Players.LocalPlayer ~= nil and Players.LocalPlayer.Character ~= nil and Players.LocalPlayer.Character.PrimaryPart and Hush_CONSTRUCTORS.Data.Silent_Target ~= nil and Hush_CONSTRUCTORS.Data.Silent_Target.Character ~= nil and Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart ~= nil) then 
										Players.LocalPlayer.Character.PrimaryPart.CFrame = Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.CFrame + getgenv().StrafeConfig.Strafe.Do360 == true and Vector3.new(Degree_X, getgenv().StrafeConfig.Strafe.Offset.Y, getgenv().StrafeConfig.Strafe.Offset.Z) or Vector3.new(getgenv().StrafeConfig.Strafe.Offset.X, getgenv().StrafeConfig.Strafe.Offset.Y, getgenv().StrafeConfig.Strafe.Offset.Z);
									end;
									task.wait(1 / getgenv().StrafeConfig.Strafe.Speed); -- 1 Second / Speed = 1 / 5 = 0.20;
								end;
							end);
						end);
						Hush_CONSTRUCTORS.Coroutines['SilentStrafe']();
					end;
					-------------------------------------
					if (HOOK_POS == true) then 
						return CFrame.new(Predicted_Pos);
					end;
				end;
			elseif (getgenv().SilentLegitSettings.HitChance.Enabled == false) and (Hush_CONSTRUCTORS.Data.Silent_Target) and (Hush_CONSTRUCTORS.Booleans.Silent == true) then
				----------------------------------------
				-- Resolver --
				if (getgenv().SilentConfigs.AutomaticResolver == true) then 
					if (Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.Velocity.X >= 35 or Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.Velocity.Y >= 20 or Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.Velocity.Z >= 35 or Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.Velocity.X <= -30 or Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.Velocity.Y <= -25 or Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.Velocity.Z <= -30) then 
						Resolver = true;
					end;
				end;
				----------------------------------------
				coroutine.wrap(function()
					if (Hush_CONSTRUCTORS.Data.Silent_Target) and (Hush_CONSTRUCTORS.Data.Silent_Target ~= nil and Hush_CONSTRUCTORS.Data.Silent_Target.Character) then 
						pcall(function()
							Data.Positions.Last = Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.Position;
							Data.Time.Last = tick();
							---------------------------------------
							wait(0.00350);
							---------------------------------------
							Data.Positions.Current = Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.Position;
							Data.Time.Current = tick();
						end);
					end;
				end)();
				----------------------------------------
				local SelectedPart = (
					getgenv().HittingChance.Main.Hitting == 0 and GetNearestPoint(Hush_CONSTRUCTORS.Data.Silent_Target.Character) or
						getgenv().HittingChance.Main.Hitting == 1 and Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart or
						getgenv().HittingChance.Main.Hitting == 2 and Hush_CONSTRUCTORS.Data.Silent_Target.Character[getgenv().SilentConfigs.BasePart] or
						getgenv().HittingChance.Main.Hitting == 3 and Hush_CONSTRUCTORS.Data.Silent_Target.Character:children()[math.random(1, #Hush_CONSTRUCTORS.Data.Silent_Target.Character:children())] or
						Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart
				) or Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart or Hush_CONSTRUCTORS.Data.Silent_Target.Character.HumanoidRootPart;
				if (Resolver == true) then
					SelectedPart.Velocity = Vector3.new(
						-- X Axis
						0 + (
							-- V1
							tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'MoveDirection' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.MoveDirection * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
								== true and math.random(1.25, 2) or getgenv().SilentConfigs.Resolver.MoveDirection).X
								or
								-- V2
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'LookVector' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.CFrame.LookVector * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
								== true and math.random(1.15, 2) or getgenv().SilentConfigs.Resolver.LookVector).X
								or
								-- V3
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'SkidStyle' and 0
								or
								-- V4
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().SilentConfigs.Resolver.Delta / 100) ).X
								or
								-- V ?
								0

						),
						-- Y Axis
						0 + (
							-- V1
							tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'MoveDirection' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.MoveDirection * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
								== true and math.random(1.25, 2) or getgenv().SilentConfigs.Resolver.MoveDirection).Y
								or
								-- V2
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'LookVector' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.CFrame.LookVector * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
								== true and math.random(1.15, 2) or getgenv().SilentConfigs.Resolver.LookVector).Y
								or
								-- V3
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'SkidStyle' and 0
								or
								-- V4
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().SilentConfigs.Resolver.Delta / 100) ).Y
								or
								-- V ?
								0

						),
						-- Z Axis
						0 + (
							-- V1
							tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'MoveDirection' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.MoveDirection * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
								== true and math.random(1.25, 2) or getgenv().SilentConfigs.Resolver.MoveDirection).Z
								or
								-- V2
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'LookVector' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.CFrame.LookVector * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
								== true and math.random(1.15, 2) or getgenv().SilentConfigs.Resolver.LookVector).Z
								or
								-- V3
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'SkidStyle' and 0
								or
								-- V4
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().SilentConfigs.Resolver.Delta / 100) ).Z
								or
								-- V ?
								0

						)
					);
					SelectedPart.AssemblyLinearVelocity = Vector3.new(
						-- X Axis
						0 + (
							-- V1
							tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'MoveDirection' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.MoveDirection * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
								== true and math.random(1.25, 2) or getgenv().SilentConfigs.Resolver.MoveDirection).X
								or
								-- V2
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'LookVector' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.CFrame.LookVector * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
								== true and math.random(1.15, 2) or getgenv().SilentConfigs.Resolver.LookVector).X
								or
								-- V3
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'SkidStyle' and 0
								or
								-- V4
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().SilentConfigs.Resolver.Delta / 100) ).X
								or
								-- V ?
								0

						),
						-- Y Axis
						0 + (
							-- V1
							tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'MoveDirection' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.MoveDirection * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
								== true and math.random(1.25, 2) or getgenv().SilentConfigs.Resolver.MoveDirection).Y
								or
								-- V2
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'LookVector' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.CFrame.LookVector * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
								== true and math.random(1.15, 2) or getgenv().SilentConfigs.Resolver.LookVector).Y
								or
								-- V3
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'SkidStyle' and 0
								or
								-- V4
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().SilentConfigs.Resolver.Delta / 100) ).Y
								or
								-- V ?
								0

						),
						-- Z Axis
						0 + (
							-- V1
							tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'MoveDirection' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.MoveDirection * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
								== true and math.random(1.25, 2) or getgenv().SilentConfigs.Resolver.MoveDirection).Z
								or
								-- V2
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'LookVector' and ((Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.CFrame.LookVector * Hush_CONSTRUCTORS.Data.Silent_Target.Character.Humanoid.WalkSpeed) * getgenv().SilentConfigs.Resolver.AutomaticPred
								== true and math.random(1.15, 2) or getgenv().SilentConfigs.Resolver.LookVector).Z
								or
								-- V3
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'SkidStyle' and 0
								or
								-- V4
								tostring(getgenv().SilentConfigs.ResolverMethod):lower() == 'Delta' and ( (Data.Positions.Current - Data.Positions.Last) / ( (Data.Time.Last - Data.Time.Current) + getgenv().SilentConfigs.Resolver.Delta / 100) ).Z
								or
								-- V ?
								0

						)
					);
				end;
				-- Predicted Pos --
				local MissChanceGen = function(Percentage) 
					return math.random() <= (Percentage / 100);
				end;
				if (	getgenv().SilentLegitSettings.Miss.Enabled == true) then 
					local Miss = MissChanceGen(	getgenv().SilentLegitSettings.Miss.Chance);
					if (Miss == true) then 
						SelectedPart.Velocity = SelectedPart.Velocity + Vector3.new(
							-- X Axis
							math.random(	getgenv().SilentLegitSettings.Miss.Intensity.X[1], 	getgenv().SilentLegitSettings.Miss.Intensity.X[2]),
							-- Y Axis
							math.random(	getgenv().SilentLegitSettings.Miss.Intensity.Y[1], 	getgenv().SilentLegitSettings.Miss.Intensity.Y[2]),
							-- Z Axis
							math.random(	getgenv().SilentLegitSettings.Miss.Intensity.Z[1], 	getgenv().SilentLegitSettings.Miss.Intensity.Z[2])
						);
					end;
				end;

				local HOOK_POS = true;

				local Predicted_Pos = SelectedPart.Position + SelectedPart.Velocity * (getgenv().PredictionConfig.Prediction.Enabled == true and getgenv().HushConfigSets.Main.SilentPrediction
					or 1);
				local OnScreenPos = workspace.CurrentCamera:WorldToViewportPoint(Predicted_Pos);
				OnScreenPos = CFrame.new(OnScreenPos);
				-- Return & Etc --
				if (getgenv().SilentConfigs.RotateToSilentTarget == true) then 
					Players.LocalPlayer.Character.PrimaryPart.CFrame = CFrame.lookAt(Players.LocalPlayer.Character.PrimaryPart.Position, Predicted_Pos); -- Since its a vector3
				end;
				-------------------------------------
				-- Self Reloading --
				if (getgenv().Checks.Checks.Reloading == true) then 
					if (Players.LocalPlayer.Character.BodyEffects ~= nil and Players.LocalPlayer.Character.BodyEffects.Reload.Value == true) then 
						HOOK_POS = false;
					end;
				else
					HOOK_POS = HOOK_POS;
				end;
				-- Grabbing --
				if (getgenv().Checks.Checks.Grabbing == true) then 
					if (Hush_CONSTRUCTORS.Data.Silent_Target.Character and Hush_CONSTRUCTORS.Data.Silent_Target.Character:FindFirstChild('GRABBING_CONSTRAINT')) then 
						HOOK_POS = false;
					end;
				end;
				-------------------------------------
				if (getgenv().StrafeConfig.Strafe.Enabled == true) then
					Hush_CONSTRUCTORS.Coroutines['SilentStrafe'] = coroutine.wrap(function()
						local Degree_X = 0;
						pcall(function()
							while (true) and (getgenv().Hush) and (getgenv().StrafeConfig.Strafe.Enabled == true) do
								Degree_X = Degree_X + 1
								if (Degree_X >= 360) then 
									Degree_X = 0;
								end;
								if (Players.LocalPlayer ~= nil and Players.LocalPlayer.Character ~= nil and Players.LocalPlayer.Character.PrimaryPart and Hush_CONSTRUCTORS.Data.Silent_Target ~= nil and Hush_CONSTRUCTORS.Data.Silent_Target.Character ~= nil and Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart ~= nil) then 
									Players.LocalPlayer.Character.PrimaryPart.CFrame = Hush_CONSTRUCTORS.Data.Silent_Target.Character.PrimaryPart.CFrame + getgenv().StrafeConfig.Strafe.Do360 == true and Vector3.new(Degree_X, getgenv().StrafeConfig.Strafe.Offset.Y, getgenv().StrafeConfig.Strafe.Offset.Z) or Vector3.new(getgenv().StrafeConfig.Strafe.Offset.X, getgenv().StrafeConfig.Strafe.Offset.Y, getgenv().StrafeConfig.Strafe.Offset.Z);
								end;
								task.wait(1 / getgenv().StrafeConfig.Strafe.Speed); -- 1 Second / Speed = 1 / 5 = 0.20;
							end;
						end);
					end);
					Hush_CONSTRUCTORS.Coroutines['SilentStrafe']();
				end;
				if (HOOK_POS == true) then 
					return CFrame.new(Predicted_Pos);
				end;
			end;
		end;
		return backupindex(self, idx);
	end);
end)();





local mt = getrawmetatable(game)
local backupnamecall = mt.__namecall
local backupnewindex = mt.__newindex
local backupindex = mt.__index 
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
	local method = getnamecallmethod()
	local args = {...}


	if typeof(args[2]) == "Vector3" then
		shootArgument = args[1]
	end

	if game.PlaceId == 9825515356 then -- afk bypass in customs
		if args[1] == "RequestAFKDisplay" then
			args[2] = false
			return backupnamecall(self, unpack(args))
		end
	end

	return backupnamecall(self, ...)
end)

















































































































































































































































-- ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ --
